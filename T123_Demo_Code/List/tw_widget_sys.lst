C51 COMPILER V7.50   TW_WIDGET_SYS                                                         06/16/2017 08:24:38 PAGE 1   


C51 COMPILER V7.50, COMPILATION OF MODULE TW_WIDGET_SYS
OBJECT MODULE PLACED IN .\Object\tw_widget_sys.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\tw_lib\sys\tw_widget_sys.c LARGE OMF2 BROWSE INCDIR(.\IncludeFile;..\tw_
                    -lib\sys;..\tw_lib\drivers) DEFINE(T123AI) DEBUG PRINT(.\List\tw_widget_sys.lst) TABS(2) OBJECT(.\Object\tw_widget_sys.ob
                    -j)

line level    source

   1          /**
   2           *  @file   tw_widget_sys.c
   3           *  @brief  terawins UI widget system
   4           *  $Id: tw_widget_sys.c,v 1.51 2013/11/21 10:46:44 onejoe Exp $
   5           *  $Author: onejoe $
   6           *  $Revision: 1.51 $
   7           *
   8           *  Copyright (c) 2011 Terawins Inc. All rights reserved.
   9           *
  10           *  @date   2011/09/15  ken     New file.
  11           *
  12           */
  13          
  14          #include "tw_widget_sys.h"
  15          #include "sys.h"
  16          #include "spiosd.h"
  17          #include "osd2api.h"
  18          #include "spirw.h"
  19          #include "iccontrol.h"
  20          #include "rc.h"
  21          #include "reg_tw.h"
  22          //#include "res.h"
  23          
  24          /* DEBUG MODE SETTING */
  25          //#define TW_WG_DEBUG_MODE
  26          
  27          /* Status variable 
  28           *    CUR_PAGE_ID   current of page ID
  29           *    CUR_MENU_P    current of OSD2 menu of struct
  30           *    CUR_MENU_RES  current of OSD2 menu of resource
  31           *    CUR_TOF_RES   current of TOF  of resource
  32           *    CUR_BK_ID   current of Background (IMG/TWBC) of ID
  33           *    CUR_SPR_ID      current of Sprite of ID
  34           *    CUR_ICONSET_NUM current of ICON SET of number
  35           *      CUR_2BP_IDX   current of OSD2 2BP start index
  36           */
  37          unsigned char CUR_PAGE_ID=0xFF;
  38          struct tw_menu* CUR_MENU_P;
  39          struct res_menu_t CUR_MENU_RES;  
  40          struct res_tof_t CUR_TOF_RES;
  41          static unsigned short CUR_BK_ID= 0xFFFF;
  42          static unsigned short CUR_SPR_ID= 0xFFFF; 
  43          static unsigned short CUR_2BP_IDX _at_ 0x00A8;     //add for 2bp twfont, use _at_ preempt important memory
             -.
  44          static unsigned char CUR_ICONSET_NUM= 0;
  45          static unsigned short menu_string_start_index = 0;
  46          
  47          #ifndef NO_SUPPORT_1BP_ROM_FONT
  48          static unsigned char SUPPORT_1BP_ROM= 0;
  49          #endif
  50          
  51          extern unsigned char tw_page_handler(unsigned char id, TW_EVENT* event);
  52          
C51 COMPILER V7.50   TW_WIDGET_SYS                                                         06/16/2017 08:24:38 PAGE 2   

  53          /*
  54           * Synopsis     unsigned char region_check(TW_EVENT* event, 
  55           *                      unsigned int x,
  56           *                      unsigned int y,
  57           *                      unsigned int w,
  58           *                      unsigned int h,
  59           *                      unsigned char type);
  60           * Description  check touch location whether in region.         _J|碰c是否位於O定^域
  61           * Parameters   event - event (touch event) of tw widget system   ?面系y之事件
  62           *        x   - x of coordinate of region           xS座
  63           *              y   - y of coordinate of region           yS座
  64           *              w   - width of region               ^域?度 
  65           *              h   - height of region                ^域高度
  66           *              type  - 1: image/twbc, 2: sprite, 3: OSD2
  67           * Return       1 for in region.
  68           */
  69          unsigned char region_check(TW_EVENT* event, unsigned int x, unsigned int y, unsigned int w, unsigned int h
             -, unsigned char type)
  70          {
  71   1          char ret = 0;
  72   1      
  73   1        if(type==TW_UI_TYPE_OSD2) {
  74   2          x=x*CUR_MENU_P->font_w; y=y*CUR_MENU_P->font_h; w=w*CUR_MENU_P->font_w; h=h*CUR_MENU_P->font_h;
  75   2        }   
  76   1      
  77   1          dbg(3, ("x=[%u] y=[%u] w=[%u] h=[%u]!\n", x, y, w, h));
  78   1      
  79   1          if((event->type==TW_EVENT_TYPE_TOUCH_DOWN)||(event->type==TW_EVENT_TYPE_TOUCH_RELEASE)||(event->type==
             -TW_EVENT_TYPE_TOUCH_MOTION)||(event->type==TW_EVENT_TYPE_TOUCH_REPEAT))
  80   1              if((event->touch_panel.x > x) && (event->touch_panel.x < x+w) && (event->touch_panel.y > y) && (ev
             -ent->touch_panel.y < y+h)) {
  81   2                  dbg(3, ("in region!\n"));
  82   2                  ret = 1;
  83   2              }
  84   1      
  85   1          return ret;
  86   1      }
  87          
  88          /*
  89           * Synopsis     void next_iconset(void);
  90           * Description  change to next icon set. (multi-language) 切Q至下一MD(多Z言)
  91           * Parameters   none
  92           * Return       none
  93           * NOTE         max of icon set is 8
  94           */
  95          void next_iconset(void)
  96          {
  97   1        CUR_ICONSET_NUM++;
  98   1        if(CUR_ICONSET_NUM>8)
  99   1          CUR_ICONSET_NUM= 1; 
 100   1        dbg(3, ("CUR_ICONSET_NUM= %bu!\n\r", CUR_ICONSET_NUM));
 101   1      }
 102          
 103          /*
 104           * Synopsis     void set_iconset_num(unsigned char num);
 105           * Description  setting number of icon set. (multi-language)  O定@示D私Me(多Z言)
 106           * Parameters   num - number of icon set    D私M??
 107           * Return       none
 108           * NOTE         max of icon set is 8
 109           */
 110          void set_iconset_num(unsigned char num)
 111          {
C51 COMPILER V7.50   TW_WIDGET_SYS                                                         06/16/2017 08:24:38 PAGE 3   

 112   1        CUR_ICONSET_NUM= num;
 113   1        if(CUR_ICONSET_NUM>8)
 114   1          CUR_ICONSET_NUM= 1; 
 115   1        dbg(3, ("CUR_ICONSET_NUM= %bu!\n\r", CUR_ICONSET_NUM));
 116   1      }
 117          
 118          /*
 119           * Synopsis     unsigned char get_iconset_num(void);
 120           * Description  getting number of icon set. (multi-language)  x取D私M盗(多Z言)
 121           * Parameters   none
 122           * Return       current of number of icon set
 123           * NOTE         max of icon set is 8
 124           */
 125          unsigned char get_iconset_num(void)
 126          { 
 127   1        dbg(3, ("CUR_ICONSET_NUM= %bu!\n\r", CUR_ICONSET_NUM));
 128   1        return CUR_ICONSET_NUM;
 129   1      }
 130          
 131          /*
 132           * Synopsis     void tw_load_oregs(unsigned short id);
 133           * Description  loading for OSD2 of registers table       x取OSD2O定表
 134           * Parameters   id  - OSD2 registers table of resource ID   O定表物件ID
 135           * Return       none
 136           * NOTE         OSD_31[0] as a use 1BP/ROM font of bit for firmware,
 137           *        so pattern fill function is can't use 
 138           */
 139          void tw_load_oregs(unsigned short id)
 140          {
 141   1        char rc= 0;
 142   1        struct res_oreg_t oreg_s;
 143   1        
 144   1      #ifdef TW_WG_DEBUG_MODE
                show_resource_header(id);
              #endif
 147   1        
 148   1        get_res_oreg(id, &oreg_s);
 149   1        
 150   1        osd_wr_regs_tbl(oreg_s.base_addr, oreg_s.length);
 151   1      
 152   1        SUPPORT_1BP_ROM= 0;
 153   1      
 154   1      #ifndef NO_SUPPORT_1BP_ROM_FONT
 155   1        if(osd_cfg_read(OSD_PT_LUT_BASEADD)==0x01) {
 156   2          SUPPORT_1BP_ROM= 1;
 157   2          dbg(3, ("Support 1BP/ROM Font version!\n"));
 158   2        }
 159   1      #endif        
 160   1      }
 161          
 162          /*
 163           * Synopsis     void _tw_load_menu_at(unsigned short id, unsigned short addr);
 164           * Description  loading for OSD2 of MEMU data (advaced application)   x取OSD2 menuY料(MA函式)
 165           * Parameters   id    - OSD2 MENU data of resource ID         menu物件ID
 166           *        addr  - assingned a OSD2 RAM of base address      oRAM地址
 167           * Return       none
 168           * NOTE         assingend a OSD2 RAM of base address for application,
 169           *        ex. double buffer for OSD2 MENU swap 
 170           */
 171          #define DMA_MAX_LENGTH  0x2000 
 172          void _tw_load_menu_at(unsigned short id, unsigned short addr)
 173          {
C51 COMPILER V7.50   TW_WIDGET_SYS                                                         06/16/2017 08:24:38 PAGE 4   

 174   1        char rc= 0;
 175   1        unsigned char i=0, count=0;
 176   1        struct res_menu_t menu_s;
 177   1      
 178   1      #ifdef TW_WG_DEBUG_MODE
                show_resource_header(id);
              #endif
 181   1      
 182   1        get_res_menu(id, &menu_s);
 183   1      
 184   1        count = (menu_s.length/DMA_MAX_LENGTH);
 185   1      
 186   1      #ifdef TW_WG_DEBUG_MODE
                dbg(0, (">>>> MENU LENGTH %u !\n", menu_s.length));
              #endif
 189   1      
 190   1          for(i=0; i< count; i++) {
 191   2          spi_dma2oram((menu_s.base_addr+(i*DMA_MAX_LENGTH)), 
 192   2              (addr+(i*DMA_MAX_LENGTH/2)), 
 193   2              DMA_MAX_LENGTH);
 194   2      #ifdef TW_WG_DEBUG_MODE   
                  dbg(0, ("spi_dma2oram(%08lX, %08X, %08X)\n", 
                      (menu_s.base_addr+(i*DMA_MAX_LENGTH)), 
                      (addr+(i*DMA_MAX_LENGTH/2)), 
                      DMA_MAX_LENGTH));
              
                  osd_oram_dump((addr+(i*DMA_MAX_LENGTH/2)), DMA_MAX_LENGTH/2);
              #endif
 202   2        }
 203   1        if((menu_s.length%DMA_MAX_LENGTH)) {
 204   2          spi_dma2oram((menu_s.base_addr+(i*DMA_MAX_LENGTH)), 
 205   2              (addr+(i*DMA_MAX_LENGTH/2)), 
 206   2              (menu_s.length%DMA_MAX_LENGTH));
 207   2      #ifdef TW_WG_DEBUG_MODE   
                  dbg(0, ("spi_dma2oram(%08lX, %08X, %08X)\n", 
                      (menu_s.base_addr+(i*DMA_MAX_LENGTH)), 
                      (addr+(i*DMA_MAX_LENGTH/2)), 
                      (menu_s.length%DMA_MAX_LENGTH)));
                  osd_oram_dump((addr+(i*DMA_MAX_LENGTH/2)), (menu_s.length%DMA_MAX_LENGTH)/2);
              #endif  
 214   2        }
 215   1      
 216   1        /* setup to 2bp tof */
 217   1        CUR_2BP_IDX = osd_cfg_read(0x02) * 2;
 218   1      }
 219          
 220          /*
 221           * Synopsis     void tw_load_menu(struct tw_menu* pmenu);
 222           * Description  loading for OSD2 of MEMU data       x取OSD2 menuY料
 223           * Parameters   pmenu - point of OSD2 MENU of struct    menu物件指
 224           * Return       none
 225           */
 226          void tw_load_menu(struct tw_menu* pmenu)
 227          {
 228   1        _tw_load_menu_at(pmenu->menuID, pmenu->addr);
 229   1      }
 230          
 231          /*
 232           * Synopsis     void tw_load_icon(unsigned short id, unsigned short *oaddr);
 233           * Description  loading for OSD2 of ICON(Fonts) data      x取osd2 icon(字型)Y料
 234           * Parameters   id    - OSD2 MENU data of resource ID     icon物件指    
 235           *        *oaddr  - point of OSD2 base address (load after add a size of ICON)
C51 COMPILER V7.50   TW_WIDGET_SYS                                                         06/16/2017 08:24:38 PAGE 5   

 236           * Return       none
 237           */
 238          void tw_load_icon(unsigned short id, unsigned short *oaddr)
 239          {
 240   1        char rc= 0;
 241   1        unsigned char i= 0;
 242   1        unsigned short count= 0;
 243   1        struct res_icon_t icon_s;
 244   1      
 245   1        if(id == 0xFFFF)
 246   1          return;
 247   1      #ifdef TW_WG_DEBUG_MODE
                show_resource_header(id);
              #endif
 250   1      
 251   1        get_res_icon(id, &icon_s);
 252   1      
 253   1        count = (icon_s.font_h*icon_s.font_w/((8/icon_s.bp)));
 254   1        if(count%2) 
 255   1          count++;   
 256   1        count*= icon_s.count;  
 257   1        count = (count/DMA_MAX_LENGTH);                
 258   1      
 259   1          for(i=0; i< count; i++) {
 260   2          (*oaddr)+= (i==0?0:(DMA_MAX_LENGTH/2));
 261   2          spi_dma2oram((icon_s.base_addr+(i*DMA_MAX_LENGTH)), 
 262   2              (*oaddr), 
 263   2              DMA_MAX_LENGTH);
 264   2      #ifdef TW_WG_DEBUG_MODE   
                  dbg(0, ("spi_dma2oram(%08lX, %08X, %08X)\n", 
                      (icon_s.base_addr+(i*DMA_MAX_LENGTH)), 
                      (*oaddr), 
                      DMA_MAX_LENGTH));
                  osd_oram_dump((*oaddr), DMA_MAX_LENGTH/2);
              #endif
 271   2        }
 272   1        //count = ((icon_s.count*icon_s.font_h*icon_s.font_w)/((8/icon_s.bp)));
 273   1        count = (icon_s.font_h*icon_s.font_w/((8/icon_s.bp)));
 274   1        if(count%2) 
 275   1          count++;   
 276   1        count*= icon_s.count;  
 277   1      
 278   1        if((count%DMA_MAX_LENGTH)) {
 279   2          (*oaddr)+= (i==0?0:(DMA_MAX_LENGTH/2));
 280   2          spi_dma2oram((icon_s.base_addr+(i*DMA_MAX_LENGTH)), 
 281   2              (*oaddr), 
 282   2              (count%DMA_MAX_LENGTH));
 283   2          
 284   2      #ifdef TW_WG_DEBUG_MODE   
                  dbg(0, ("spi_dma2oram(%08lX, %08X, %08X)\n", 
                      (icon_s.base_addr+(i*DMA_MAX_LENGTH)), 
                      (*oaddr), 
                      (count%DMA_MAX_LENGTH)));
                  osd_oram_dump((*oaddr), (count%DMA_MAX_LENGTH)/2);
              #endif
 291   2          (*oaddr)+= ((count%DMA_MAX_LENGTH)/2);
 292   2        }
 293   1      }
 294          
 295          /*
 296           * Synopsis     void _tw_load_tiles_at(unsigned short id, unsigned short oram_addr);
 297           * Description  loading for OSD2 of tiles(ICONs) table (advaced application)  x取OSD2 tile表(MA函)
C51 COMPILER V7.50   TW_WIDGET_SYS                                                         06/16/2017 08:24:38 PAGE 6   

 298           * Parameters   id      - OSD2 tiles(ICONs) table of resource ID  tile表 ID
 299           *        oram_addr - assingned a OSD2 RAM of base address    ORAM 地址
 300           * Return       none
 301           * NOTE         assingend a OSD2 RAM of base address for application,
 302           *        ex. double buffer for OSD2 ICON swap 
 303           */
 304          void _tw_load_tiles_at(unsigned short id, unsigned short oram_addr)
 305          {
 306   1        char rc= 0;
 307   1        unsigned char i= 0;
 308   1        unsigned short icon_id= 0;
 309   1        unsigned short tmp_addr= oram_addr;
 310   1        
 311   1        struct res_tile_t tile_s;
 312   1      
 313   1        if(id == 0xFFFF)
 314   1          return;
 315   1      
 316   1      #ifdef TW_WG_DEBUG_MODE
                show_resource_header(id);
              #endif  
 319   1        
 320   1        get_res_tile(id, &tile_s);
 321   1        spi_dma2xram(tile_s.base_addr, (unsigned short)(&icon_id), sizeof(unsigned short));
 322   1        if(icon_id==0) {
 323   2          //INFO(("This Cangeable Tables!\n\r"));
 324   2      
 325   2          if((CUR_ICONSET_NUM>=tile_s.length)||(CUR_ICONSET_NUM<=0))
 326   2            CUR_ICONSET_NUM= 1;
 327   2      
 328   2          spi_dma2xram((tile_s.base_addr+(2*CUR_ICONSET_NUM)), (unsigned short)(&icon_id), sizeof(unsigned short))
             -;
 329   2          get_res_tile(icon_id, &tile_s);
 330   2        }
 331   1      
 332   1        for(i=0; i<tile_s.length; i++) {
 333   2          spi_dma2xram((tile_s.base_addr+(i*2)), (unsigned short)(&icon_id), sizeof(unsigned short));   
 334   2          tw_load_icon(icon_id, &tmp_addr);   
 335   2        } 
 336   1      }
 337          
 338          /**
 339           * @func    find_ch_icon
 340           * @brief   icon ID of mapping function with ICONSET (changeable).
 341           * @param   id    dynamic of icon ID
 342           *      tilesID icon ID belongs to the this menu of tiles ID 
 343           * @return  0 if not changeable menu or other errors
 344           */
 345          unsigned short find_ch_icon(unsigned short id, unsigned short tilesID)
 346          {
 347   1        char rc= 0;
 348   1        unsigned char i= 0;
 349   1        unsigned short icon_id= 0;  
 350   1        unsigned long tmp_addr= 0;  
 351   1        struct res_tile_t tile_s;
 352   1      
 353   1        if(id == 0xFFFF)
 354   1          return 0; 
 355   1        
 356   1        /* get menu of tiles structure with tiles ID */
 357   1        get_res_tile(tilesID, &tile_s);
 358   1        /* get table of first icon ID with base address */
C51 COMPILER V7.50   TW_WIDGET_SYS                                                         06/16/2017 08:24:38 PAGE 7   

 359   1        spi_dma2xram(tile_s.base_addr, (unsigned short)(&icon_id), sizeof(unsigned short));
 360   1      
 361   1        if(icon_id==0) {  // this change table if icon ID is '0'
 362   2      
 363   2          /* check current of ICONSET */
 364   2          if((CUR_ICONSET_NUM>=tile_s.length)||(CUR_ICONSET_NUM<=1)) {
 365   3            CUR_ICONSET_NUM= 1;
 366   3            return id;  // default ICON SET if '1' or unknow
 367   3          }
 368   2          
 369   2          /* get changeable of defalut table of tiles structure */
 370   2          spi_dma2xram(tile_s.base_addr+2, (unsigned short)(&icon_id), sizeof(unsigned short));
 371   2          tmp_addr = tile_s.base_addr;
 372   2          get_res_tile(icon_id, &tile_s);
 373   2      
 374   2          /* search icon ID of order in default table */
 375   2          for(i=0; i<tile_s.length; i++) {
 376   3            spi_dma2xram((tile_s.base_addr+(i*2)), (unsigned short)(&icon_id), sizeof(unsigned short));   
 377   3            if(id == icon_id)
 378   3              break;    // find 
 379   3          }
 380   2      
 381   2          if(i >= tile_s.length) {
 382   3            ERROR(("can't find chageable of icon id!\n"));
 383   3            return 0;
 384   3          }
 385   2      
 386   2          /* get current ICON SET of tiles structure */
 387   2          spi_dma2xram((tmp_addr+(2*CUR_ICONSET_NUM)), (unsigned short)(&icon_id), sizeof(unsigned short));
 388   2          get_res_tile(icon_id, &tile_s);
 389   2      
 390   2          /* get mapping of icon ID */
 391   2          spi_dma2xram((tile_s.base_addr+(i*2)), (unsigned short)(&icon_id), sizeof(unsigned short));
 392   2          return icon_id;
 393   2      
 394   2        } else {
 395   2          ERROR(("this menu not has chageable fucntion!\n"));
 396   2          return 0; 
 397   2        } 
 398   1      }
 399          
 400          /*
 401           * Synopsis     void tw_load_tiles(unsigned short id);
 402           * Description  loading for OSD2 of tiles(ICONs) table      x取OSD2 tile表
 403           * Parameters   id  - OSD2 tiles(ICONs) table of resource ID  tile表 ID
 404           * Return       none
 405           * NOTE         default ICON(Font) of start address is 0 for firmware
 406           */
 407          void tw_load_tiles(unsigned short id)
 408          {
 409   1        _tw_load_tiles_at(id, 0);
 410   1      }
 411          
 412          /*
 413           * Synopsis     void tw_load_luts(unsigned short id);
 414           * Description  loading for OSD2 of LUT table     x取OSD2 lut表
 415           * Parameters   id  - OSD2 LUT table of resource ID   lut表 ID
 416           * Return       none
 417           * NOTE         include are Main LUT, 2BP remap LUT, BG remap LUT
 418           */
 419          void tw_load_luts(unsigned short id)
 420          {
C51 COMPILER V7.50   TW_WIDGET_SYS                                                         06/16/2017 08:24:38 PAGE 8   

 421   1        char rc= 0;
 422   1        struct res_lut_t lut_s; 
 423   1        
 424   1      #ifdef TW_WG_DEBUG_MODE
                show_resource_header(id);
              #endif
 427   1      
 428   1        get_res_lut(id, &lut_s);
 429   1      
 430   1        osd_wr_lut_tbl(lut_s.lut_addr, (lut_s.main_len*4)); 
 431   1        osd_wr_2bp_lut_tbl((lut_s.lut_addr+(lut_s.main_len*4)), (lut_s.re_2bp_len*1));  
 432   1        osd_wr_bg_lut_tbl((lut_s.lut_addr+(lut_s.main_len*4)+(lut_s.re_2bp_len*1)), (lut_s.re_bg_len*1));
 433   1              
 434   1      }
 435          
 436          /*
 437           * Synopsis     void tw_img_draw(struct tw_img* pimg);
 438           * Description  setting registers for show image (SPIOSD) O定img@示所需捍嫫
 439           * Parameters   pimg  - point of image of struct      img物件指
 440           * Return       none
 441           * NOTE         this function just setting registers,
 442           *        if SPIOSD of status is disable, 
 443           *        need change to enable (sosd_enable)
 444           */
 445          void tw_img_draw(struct tw_img* pimg)
 446          {
 447   1        char rc= 0;
 448   1        struct res_img_t img_s;
 449   1        
 450   1      #ifdef TW_WG_DEBUG_MODE
                show_resource_header(pimg->imgID);
              #endif
 453   1        
 454   1        get_res_img(pimg->imgID, &img_s);
 455   1        
 456   1        _sosd_pLUT_addr(img_s.lut_addr);
 457   1          _sosd_img_addr(img_s.index_addr);
 458   1          _sosd_img_ls(img_s.line_jump);
 459   1          _sosd_img_window(pimg->width, pimg->height);
 460   1        _sosd_img_loca(pimg->x, pimg->y);
 461   1      
 462   1        CUR_BK_ID = pimg->imgID;
 463   1      
 464   1      } 
 465          
 466          /*
 467           * Synopsis     void tw_spr_draw(struct tw_spr* pspr);
 468           * Description  setting registers for show sprite (SPIOSD)  O定spr@示所需捍嫫
 469           * Parameters   pspr  - point of sprite of struct     spr物件指
 470           * Return       none
 471           * NOTE         this function just setting registers,
 472           *        if SPIOSD-Sprite of status is disable, 
 473           *        need change to enable (sosd_spr_enable)
 474           */
 475          void tw_spr_draw(struct tw_spr* pspr)
 476          {
 477   1        char rc= 0;
 478   1        struct res_spr_t spr_s;
 479   1        unsigned long tmpAddr= 0;
 480   1      
 481   1      #ifdef TW_WG_DEBUG_MODE
                show_resource_header(pspr->sprID);
C51 COMPILER V7.50   TW_WIDGET_SYS                                                         06/16/2017 08:24:38 PAGE 9   

              #endif
 484   1          
 485   1        get_res_spr(pspr->sprID, &spr_s);
 486   1      
 487   1          _sosd_sLUT_addr(spr_s.lut_addr);
 488   1        if(pspr->cnt<spr_s.count) {
 489   2          tmpAddr = pspr->width*pspr->height;
 490   2          tmpAddr *= pspr->cnt;
 491   2          tmpAddr += spr_s.index_addr;
 492   2        } else if(pspr->cnt>spr_s.count) {
 493   2          tmpAddr = (spr_s.index_addr);
 494   2          ERROR(("Sprite count is outrange!\n"));
 495   2        } else {
 496   2          tmpAddr = (spr_s.index_addr);
 497   2        }           
 498   1          _sosd_spr_addr(tmpAddr);
 499   1        _sosd_spr_ls(spr_s.line_jump);
 500   1          _sosd_spr_window(pspr->width, pspr->height);
 501   1        _sosd_spr_loca(pspr->x, pspr->y); 
 502   1        
 503   1        CUR_SPR_ID = pspr->sprID;  
 504   1      
 505   1      }
 506          
 507          /*
 508           * Synopsis     void tw_get_spr_idx(unsigned short id, unsigned long *addr);
 509           * Description  getting base address of sprite (SPIOSD)   x取spr物件地址
 510           * Parameters   id    - SPIOSD-Sprite of resource ID    spr物件ID
 511           *        *addr - result was save in this point   spr物件地址(指)
 512           * Return       none
 513           */
 514          void tw_get_spr_idx(unsigned short id, unsigned long *addr)
 515          {
 516   1        struct res_spr_t spr_s;
 517   1          
 518   1        get_res_spr(id, &spr_s);
 519   1      
 520   1        *addr = spr_s.index_addr;
 521   1      }
 522          
 523          /*
 524           * Synopsis     void tw_spr_action(struct tw_spr* pspr);
 525           * Description  change a sprite. (animation)      切Q@示sprite
 526           * Parameters   pspr  - point of sprite of struct   sprite物件指
 527           * Return       none
 528           * NOTE     maybe some Sprite of LUT is same
 529           */
 530          void tw_spr_action(struct tw_spr* pspr)
 531          { 
 532   1        unsigned short id = CUR_SPR_ID;
 533   1        
 534   1        tw_spr_draw(pspr);
 535   1      
 536   1        if(pspr->sprID == id)
 537   1          sosd_sp_enable(DONT_LOAD);
 538   1        else
 539   1          sosd_sp_enable(LOAD_LUT);
 540   1      }
 541          
 542          /*
 543           * Synopsis     void tw_td_draw(struct tw_td* ptd);
 544           * Description  setting registers for show twbc (SPIOSD)  O定TD捍嫫
C51 COMPILER V7.50   TW_WIDGET_SYS                                                         06/16/2017 08:24:38 PAGE 10  

 545           * Parameters   ptd - point of twbc of struct       TD物件指
 546           * Return       none
 547           * NOTE         this function just setting registers,       ㄔㄨㄉㄗㄉㄌ!
 548           *        if SPIOSD and SPIOSD-TD of status is disable, 
 549           *        need change to enable (sosd_td_enable, sosd_enable)
 550           */
 551          void tw_td_draw(struct tw_td* ptd)
 552          {
 553   1        char rc= 0;
 554   1        struct res_td_t td_s;
 555   1        
 556   1      #ifdef TW_WG_DEBUG_MODE
                show_resource_header(ptd->tdID);
              #endif
 559   1        
 560   1        get_res_td(ptd->tdID, &td_s);
 561   1        
 562   1        _sosd_tdc_addr(td_s.color_addr);
 563   1          _sosd_img_addr(td_s.index_addr);
 564   1          _sosd_td_ls(td_s.line_jump);
 565   1        _sosd_tdc_h_size(td_s.line_jump);
 566   1          _sosd_td_window(ptd->width, ptd->height);
 567   1        _sosd_td_loca(ptd->x, ptd->y);
 568   1        _sosd_td_spilt_mode_en();
 569   1      
 570   1        CUR_BK_ID = ptd->tdID;
 571   1      
 572   1      }
 573          
 574          /*
 575           * Synopsis     static void tw_fixed_menu2(void);
 576           * Description  avoided incorrect of display when OSD2 MENU-2 no assigned a space 
 577           * Parameters   none
 578           * Return       none
 579           * NOTE         assigned 2 words space in last RAM for OSD2 MENU-2 
 580           */
 581          static void tw_fixed_menu2(void)
 582          {
 583   1        osd_set_ram_addr(0x3FFE);
 584   1        osd_set_ram_data(0x0801);
 585   1        osd_set_ram_data(0x0000); // 0 char
 586   1      }
 587          
 588          /*
 589           * Synopsis     void tw_menu_draw(struct tw_menu* pmenu);
 590           * Description  load OSD2 data for show OSD2      d入OSD2Y料
 591           * Parameters   *tw_menu  - point of OSD2 of struct OSD2物件指
 592           * Return       none
 593           * NOTE         this function just load OSD2 data to OSD RAM,
 594           *        need disable OSD2 before, 
 595           *        and change to enable (sosd_enable) when load finish
 596           */
 597          void tw_menu_draw(struct tw_menu* pmenu)
 598          {     
 599   1        CUR_MENU_P = pmenu;
 600   1      
 601   1        get_res_menu(CUR_MENU_P->menuID, &CUR_MENU_RES);
 602   1        if(CUR_MENU_P->tofID != 0xffff)
 603   1          get_res_tof(CUR_MENU_P->tofID, &CUR_TOF_RES);
 604   1      
 605   1          tw_load_oregs(pmenu->regsID);
 606   1        tw_load_luts(pmenu->lutsID);
C51 COMPILER V7.50   TW_WIDGET_SYS                                                         06/16/2017 08:24:38 PAGE 11  

 607   1          tw_load_tiles(pmenu->tilesID);
 608   1          tw_load_menu(pmenu);
 609   1      
 610   1        if(osd_cfg_read(OSD_PT_LUT_BASEADD)==0x01)
 611   1          tw_fixed_menu2();
 612   1      
 613   1        tw_menu_reset_index();
 614   1      }
 615          
 616          /*
 617           * Synopsis     unsigned char check_color_config(unsigned short index, 
 618           *                        unsigned char offset,
 619           *                        unsigned char color);
 620           * Description  check type of color index         _J色P??之?型
 621           * Parameters   index - font of start index of ICON   icon第一?tile之??
 622           *        offset  - font of offset          icon於tile表之偏移量
 623           *        color - color index of ICON of struct   icon色P??
 624           * Return       color index (type of in RAM)        icon色P??(根bp挡煌，M行偏移)
 625           * NOTE         1BP/ROM Font of color type is different,
 626           *        check font of type by index and offset,
 627           *        and change type of color index
 628           */
 629          #ifndef NO_SUPPORT_1BP_ROM_FONT
 630          unsigned char check_color_config(unsigned short index, unsigned char offset, unsigned char color)
 631          {
 632   1        unsigned short FONT_START= 0;
 633   1        unsigned char ccolor= 0;
 634   1      
 635   1        if(SUPPORT_1BP_ROM) { 
 636   2          FONT_START= osd_cfg_read(OSD_CHAR2BP_FONT_INDEX);
 637   2          if(FONT_START==0xFF)
 638   2            FONT_START= osd_cfg_read(OSD_CHAR4BP_FONT_INDEX);
 639   2          FONT_START <<= 1;
 640   2      
 641   2      #ifdef  VERSION_102
                  if(index<0xFF)
                    index+= offset;
                  else
                    index= offset;
              #else
 647   2              /* add on version v1.04 */
 648   2              index+= offset;
 649   2      #endif      
 650   2        
 651   2          if(index<FONT_START) {
 652   3            /* 1BP/ROM Font */
 653   3            ccolor = color;//(color&0x0F)|((color&0xF0)<<1);
 654   3          } else {
 655   3            /* 2BP/4BP/8BP Font */
 656   3            ccolor = (color&0x0F);
 657   3          }
 658   2        } else {
 659   2          /* 2BP/4BP/8BP Font */
 660   2          ccolor = (color&0x0F);
 661   2        }
 662   1      
 663   1        return ccolor;
 664   1      }
 665          #endif
 666          
 667          /*
 668           * Synopsis     void _icon_draw_at(unsigned short index,
C51 COMPILER V7.50   TW_WIDGET_SYS                                                         06/16/2017 08:24:38 PAGE 12  

 669           *                  unsigned char color,
 670           *                  unsigned char x,
 671           *                  unsigned char y,
 672           *                  unsigned char width,
 673           *                  unsigned char height,
 674           *                  unsigned short menu_addr,
 675           *                  unsigned char menu_width,
 676           *                  unsigned short offset,
 677           *                  unsigned char blinking);
 678           * Description  writting ICON(Font) of index(font, color) at OSD2-MENU(OSD RAM) (advanced application) i
             -conN上menu(MA函式)
 679           * Parameters   index   - start font index of ICON              icon起始tile??
 680           *        color   - color index of ICON               icon色P??
 681           *        x     - x of coordinate of OSD2-MENU (unit is font)   menu XS位置(tile)
 682           *              y     - y of coordinate of OSD2-MENU (unit is font)   menu YS位置(tile)
 683           *              width   - width of ICON (unit is font)            icon ?度(tile)            
 684           *              height    - height of ICON (unit is font)           icon 高度(tile)
 685           *              menu_addr - base address of OSD2-MENU             menu oram地址
 686           *              menu_width  - width of OSD2-MENU (unit is font)         menu ?度(tile)
 687           *        offset    - font index of offset (for double buffer, etc.)  tile 偏移量
 688           *        blinking  - 0: none, 1: blinking                Wq
 689           * Return       none
 690           * NOTE         OSD2-MENU of every ROW of char count need same
 691           */
 692          void _icon_draw_at(unsigned short index, unsigned char color, unsigned char x, unsigned char y, unsigned c
             -har width, unsigned char height,
 693               unsigned short menu_addr, unsigned char menu_width, unsigned short offset, unsigned char blinking)
 694          {
 695   1        unsigned char w,h = 0;
 696   1        unsigned short i = 0, temp = 0;
 697   1      
 698   1      #ifdef EX_I2C_SAFE_MODE
 699   1        IC_WRITBYTE(TWIC_P0, 0xF0, SLAVE_SAFE_ADDR);
 700   1      #endif
 701   1        i=0;
 702   1      
 703   1        color <<= 1;  // lut index[8:5]
 704   1        if(blinking)
 705   1          color |= 0x20;
 706   1      
 707   1          for(h=0; h< height; h++) {
 708   2              osd_set_location_addr(x, y+h,  menu_addr, menu_width);
 709   2          for(w=0; w< width; w++) {
 710   3            temp = index+i+offset;
 711   3            temp |= (color<<8);
 712   3            osd_set_ram_data(temp);
 713   3            i++;
 714   3              }
 715   2          }
 716   1      #ifdef EX_I2C_SAFE_MODE 
 717   1        IC_WRITBYTE(TWIC_P0, 0xF0, SLAVE_WORK_ADDR);
 718   1      #endif
 719   1      }
 720          
 721          /*
 722           * Synopsis     void _tw_icon_draw_at(struct tw_icon* picon,
 723           *                  unsigned short menu_addr,
 724           *                  unsigned char menu_width,
 725           *                  unsigned short offset,
 726           *                  unsigned char blinking);
 727           * Description  writting ICON(Font) of index(font, color) at OSD2-MENU(OSD RAM) (advanced application)  i
             -conN上osd2 menu(MA函式)
C51 COMPILER V7.50   TW_WIDGET_SYS                                                         06/16/2017 08:24:38 PAGE 13  

 728           * Parameters   menu_addr - base address of OSD2-MENU             menu oram 地址
 729           *              menu_width  - width of OSD2-MENU (unit is font)         menu ?度(tile)
 730           *        offset    - font index of offset (for double buffer, etc.)  icon??於tile表中之偏移量
 731           *        blinking  - 0: none, 1: blinking                Wq
 732           * Return       none
 733           * NOTE         can assigned base address and width of OSD2-MENU
 734           *        for advance application,
 735           *        ex. double buffer
 736           */
 737          void _tw_icon_draw_at(struct tw_icon* picon, unsigned short menu_addr, unsigned char menu_width, unsigned 
             -short offset, unsigned char blinking)
 738          {   
 739   1      #ifndef NO_SUPPORT_1BP_ROM_FONT
 740   1        unsigned char color= 0;
 741   1      
 742   1        color = check_color_config(picon->index, 0, picon->color);
 743   1      
 744   1        _icon_draw_at(picon->index, color, picon->x, picon->y, picon->width, picon->height, menu_addr, menu_width
             -, offset, blinking);
 745   1      #else
                _icon_draw_at(picon->index, (picon->color&0x0F), picon->x, picon->y, picon->width, picon->height, menu_ad
             -dr, menu_width, offset, blinking);  
              #endif
 748   1      }
 749          
 750          /*
 751           * Synopsis     void _icon_draw(unsigned short index,
 752           *                  unsigned char color,
 753           *                  unsigned char x,
 754           *                  unsigned char y,
 755           *                  unsigned char width,
 756           *                  unsigned char height,
 757           *                  unsigned char blinking);
 758           * Description  writting ICON(Font) of index(font, color) at OSD2-MENU(OSD RAM) (advanced application)  i
             -conN上osd2 menu(MA函式)  
 759           * Parameters   index   - start font index of ICON            icon 起始tile??
 760           *        color   - color index of ICON             icon 色P??
 761           *        x     - x of coordinate of OSD2-MENU (unit is font) xS位置(tile)
 762           *              y     - y of coordinate of OSD2-MENU (unit is font) yS位置(tile)
 763           *              width   - width of ICON (unit is font)          icon ?度(tile) 
 764           *              height    - height of ICON (unit is font)         icon 高度(tile)
 765           *        blinking  - 0: none, 1: blinking              Wq
 766           * Return       none
 767           */
 768          void _icon_draw(unsigned short index, unsigned char color, unsigned char x, unsigned char y, unsigned char
             - width, unsigned char height, unsigned char blinking)
 769          {
 770   1        _icon_draw_at(index, color, x, y, width, height, CUR_MENU_P->addr, CUR_MENU_P->width, 0, blinking);
 771   1      }
 772          
 773          /*
 774           * Synopsis     void tw_icon_color_change(struct tw_icon* picon,
 775           *                    unsigned char color);
 776           * Description  change color index of ICON            切Qicon之色P??
 777           * Parameters   *tw_icon  - point of icon struct        icon物件指
 778           *        color   - want to change of color index   欲更Q之色P??
 779           * Return       none
 780           * NOTE         for 1BP/ROM Font
 781           */
 782          void tw_icon_color_change(struct tw_icon* picon, unsigned char color)
 783          {
 784   1        _icon_draw_at(picon->index, color, picon->x, picon->y, picon->width, picon->height, CUR_MENU_P->addr, CUR
C51 COMPILER V7.50   TW_WIDGET_SYS                                                         06/16/2017 08:24:38 PAGE 14  

             -_MENU_P->width, 0, 0);
 785   1      }
 786          
 787          /*
 788           * Synopsis     void tw_icon_1st_color(struct tw_icon* picon);
 789           * Description  change to 1st color of ICON       切Q至第一M色P
 790           * Parameters   *tw_icon  - point of icon struct    icon物件指
 791           * Return       none
 792           * NOTE         for 2BP/4BP Font
 793           */
 794          void tw_icon_1st_color(struct tw_icon* picon)
 795          {
 796   1        tw_icon_draw(picon);
 797   1      }
 798          
 799          /*
 800           * Synopsis     void tw_icon_2nd_color(struct tw_icon* picon);
 801           * Description  change to 2nd color of ICON       切Q至第二M色P
 802           * Parameters   *tw_icon  - point of icon struct    icon物件指
 803           * Return       none
 804           * NOTE         for 2BP/4BP Font
 805           */
 806          void tw_icon_2nd_color(struct tw_icon* picon)
 807          {
 808   1        _icon_draw_at(picon->index, ((picon->color)>>4), picon->x, picon->y, picon->width, picon->height, CUR_MEN
             -U_P->addr, CUR_MENU_P->width, 0, 0);
 809   1      }
 810          
 811          /*
 812           * Synopsis     void tw_icon_draw(struct tw_icon* picon);
 813           * Description  show ICON(OSD2)             @示icon於menu上
 814           * Parameters   *tw_icon  - point of icon struct    icon物件指
 815           * Return       none
 816           * NOTE         OSD2 need init and load data (tw_menu_draw) before the show ICON
 817           */
 818          void tw_icon_draw(struct tw_icon* picon)
 819          {   
 820   1      #ifndef NO_SUPPORT_1BP_ROM_FONT
 821   1        unsigned char color= 0;
 822   1      
 823   1        color = check_color_config(picon->index, 0, picon->color);
 824   1      
 825   1        _icon_draw(picon->index, color, picon->x, picon->y, picon->width, picon->height, 0);
 826   1      #else
                _icon_draw(picon->index, (picon->color&0x0F), picon->x, picon->y, picon->width, picon->height, 0);  
              #endif
 829   1      }
 830          
 831          unsigned short check_gicon_id (unsigned short id)
 832          {
 833   1        unsigned char type = 0;
 834   1        unsigned short icon_id = 0;
 835   1        struct res_tile_t tile_s;
 836   1        
 837   1        type = rc_type(id);
 838   1        if(type == TYPE_TILE) {
 839   2              /* get current ICON SET of group ICON */
 840   2              dbg(2, ("Group ICON + Changeable!\n\r"));
 841   2              get_res_tile(id, &tile_s);
 842   2              if((CUR_ICONSET_NUM>tile_s.length)||(CUR_ICONSET_NUM<=0))
 843   2            CUR_ICONSET_NUM= 1;
 844   2          spi_dma2xram((tile_s.base_addr+(2*(CUR_ICONSET_NUM-1))), (unsigned short)(&icon_id), sizeof(unsigned sho
C51 COMPILER V7.50   TW_WIDGET_SYS                                                         06/16/2017 08:24:38 PAGE 15  

             -rt));      
 845   2          } else if(type == TYPE_ICON) {
 846   2              icon_id = id;
 847   2          } else {
 848   2              ERROR(("group icon of ID type is error!\n\r"));
 849   2              return NULL;    
 850   2          }
 851   1          
 852   1          return icon_id;
 853   1      }
 854          
 855          /*
 856           * Synopsis     void tw_gicon_draw(struct tw_gicon* pgicon);
 857           * Description  show ICON(OSD2)             @示icon於menu上
 858           * Parameters   *tw_icon  - point of icon struct    icon物件指
 859           * Return       none
 860           * NOTE         OSD2 need init and load data (tw_menu_draw) before the show ICON
 861           */
 862          void tw_gicon_draw(struct tw_gicon* pgicon)
 863          {
 864   1        unsigned short icon_id = 0;
 865   1        unsigned char color = 0;
 866   1        unsigned short tmp_addr = 0;
 867   1        
 868   1          icon_id = check_gicon_id(pgicon->gicon_id);
 869   1          if(!icon_id)
 870   1              return;
 871   1          
 872   1          tmp_addr = pgicon->oram_addr;
 873   1          /* dynamic load ICON to OSDRAM */
 874   1          tw_load_icon(icon_id, &tmp_addr);
 875   1      
 876   1        color = check_color_config(pgicon->index, 0, pgicon->color);
 877   1        _icon_draw(pgicon->index, color, pgicon->x, pgicon->y, pgicon->width, pgicon->height, 0);
 878   1      }
 879          
 880          /*
 881           * Synopsis     void _icons_draw_at(unsigned char *table,
 882           *                  unsigned char color,
 883           *                  unsigned char x,
 884           *                  unsigned char y,
 885           *                  unsigned char width,
 886           *                  unsigned char height,
 887           *                  unsigned short menu_addr,
 888           *                  unsigned char menu_width,
 889           *                  unsigned short offset,
 890           *                  unsigned char blinking);
 891           * Description  writting ICONS(Font) of index(font, color) at OSD2-MENU(OSD RAM) (advanced application) 
             -iconsN上osd2 menu(MA函式)
 892           * Parameters   *table    - point of font index of table          icons index表指
 893           *        color   - color index of ICON             色P??
 894           *        x     - x of coordinate of OSD2-MENU (unit is font) xS位置(tile)
 895           *              y     - y of coordinate of OSD2-MENU (unit is font) yS位置(tile)
 896           *              width   - width of ICON (unit is font)          icon?度
 897           *              height    - height of ICON (unit is font)         icon高度
 898           *              menu_addr - base address of OSD2-MENU           menu oram 位址
 899           *              menu_width  - width of OSD2-MENU (unit is font)       memu ?度(tile)
 900           *        offset    - font index of offset              index於tile表之偏移量
 901           *        blinking  - 0: none, 1: blinking              Wq
 902           * Return       none
 903           * NOTE         OSD2-MENU of every ROW of char count need same
 904           */
C51 COMPILER V7.50   TW_WIDGET_SYS                                                         06/16/2017 08:24:38 PAGE 16  

 905          void _icons_draw_at(unsigned char *table, unsigned char color, unsigned char x, unsigned char y, unsigned 
             -char width, unsigned char height,
 906               unsigned short menu_addr, unsigned char menu_width, unsigned short offset, unsigned char blinking)
 907          {
 908   1        unsigned char w,h = 0;
 909   1        unsigned short i = 0, temp = 0;
 910   1      
 911   1      #ifdef EX_I2C_SAFE_MODE
 912   1        IC_WRITBYTE(TWIC_P0, 0xF0, SLAVE_SAFE_ADDR);
 913   1      #endif
 914   1        i=0;
 915   1      
 916   1        color <<= 1;  // lut index[8:5]
 917   1        if(blinking)
 918   1          color |= 0x20;
 919   1      
 920   1          for(h=0; h< height; h++) {
 921   2              osd_set_location_addr(x, y+h,  menu_addr, menu_width);
 922   2          for(w=0; w< width; w++) {
 923   3            temp = table[i];
 924   3            if(temp==0xFF)  /* for Blank ROM Font */
 925   3              temp= 0;
 926   3            else {
 927   4              temp = table[i]+offset;
 928   4              temp |= (color<<8);
 929   4            }
 930   3            osd_set_ram_data(temp);
 931   3            i++;
 932   3              }
 933   2          }
 934   1      #ifdef EX_I2C_SAFE_MODE 
 935   1        IC_WRITBYTE(TWIC_P0, 0xF0, SLAVE_WORK_ADDR);
 936   1      #endif
 937   1      }
 938          
 939          /*
 940           * Synopsis     void _icons_draw(unsigned char x,
 941           *                  unsigned char y,
 942           *                  unsigned char width,
 943           *                  unsigned char height,
 944           *                  unsigned char *table,
 945           *                  unsigned char color,
 946           *                  unsigned char offset,
 947           *                  unsigned char blinking);
 948           * Description  writting ICON(Font) of index(font, color) at OSD2-MENU(OSD RAM) (advanced application)  i
             -consN上osd2 menu(MA函式)
 949           * Parameters   x     - x of coordinate of OSD2-MENU (unit is font) xS位置(tile)
 950           *              y     - y of coordinate of OSD2-MENU (unit is font) yS位置(tile)
 951           *              width   - width of ICON (unit is font)          icon?度(tile) 
 952           *              height    - height of ICON (unit is font)         icon高度(tile)
 953           *        *table    - point of font index of table          icon index表指
 954           *        color   - color index of ICONS              色P??  
 955           *        offset    - font index of offset              index於tile表中之偏移量
 956           *        blinking  - 0: none, 1: blinking              Wq
 957           * Return       none
 958           */
 959          void _icons_draw(unsigned char x, unsigned char y, unsigned char width, unsigned char height, unsigned cha
             -r *table, unsigned char color, unsigned short offset, unsigned char blinking)
 960          {
 961   1      #ifndef NO_SUPPORT_1BP_ROM_FONT
 962   1        unsigned char ccolor= 0;
 963   1      
C51 COMPILER V7.50   TW_WIDGET_SYS                                                         06/16/2017 08:24:38 PAGE 17  

 964   1        ccolor = check_color_config(table[0], (SUPPORT_1BP_ROM?offset:0), color);
 965   1      
 966   1        _icons_draw_at(table, ccolor, x, y, width, height, CUR_MENU_P->addr, CUR_MENU_P->width, offset, blinking)
             -;
 967   1      #else
                _icons_draw_at(table, (color&0x0F), x, y, width, height, CUR_MENU_P->addr, CUR_MENU_P->width, offset, bli
             -nking);
              #endif
 970   1      }
 971          
 972          /*
 973           * Synopsis     void _tw_icons_draw_at(struct tw_icon* picon,
 974           *                  unsigned short menu_addr,
 975           *                  unsigned char menu_width,
 976           *                  unsigned short offset,
 977           *                  unsigned char blinking);
 978           * Description  writting ICON(Font) of index(font, color) at OSD2-MENU(OSD RAM) (advanced application)  i
             -conN上osd2 menu(MA函式)
 979           * Parameters   menu_addr - base address of OSD2-MENU             menu oram 位置
 980           *              menu_width  - width of OSD2-MENU (unit is font)         menu ?度
 981           *        offset    - menu_addr of offset (for double buffer, etc.)   menu 偏移量
 982           *        blinking  - 0: none, 1: blinking                Wq
 983           * Return       none
 984           * NOTE         can assigned base address and width of OSD2-MENU
 985           *        for advance application,
 986           *        ex. double buffer
 987           */
 988          void _tw_icons_draw_at(struct tw_icons* picon, unsigned short menu_addr, unsigned char menu_width, unsigne
             -d short offset, unsigned char blinking)
 989          {   
 990   1      #ifndef NO_SUPPORT_1BP_ROM_FONT
 991   1        unsigned char color= 0;
 992   1      
 993   1        color = check_color_config(picon->table[0], (SUPPORT_1BP_ROM?picon->offset:0), picon->color);
 994   1        _icons_draw_at(picon->table, color, picon->x, picon->y, picon->width, picon->height, menu_addr, menu_widt
             -h, (SUPPORT_1BP_ROM?picon->offset:0)+offset, blinking);
 995   1      #else
                _icons_draw_at(picon->table, (picon->color&0x0F), picon->x, picon->y, picon->width, picon->height, menu_a
             -ddr, menu_width, offset, blinking); 
              #endif
 998   1      }
 999          
1000          /*
1001           * Synopsis     void tw_icons_color_change(struct tw_icons* picon,
1002           *                    unsigned char color);
1003           * Description  change color index of ICONS           切Qicons色P
1004           * Parameters   *tw_icons - point of icon struct        icons物件指
1005           *        color   - want to change of color index   欲切Q之色P??
1006           * Return       none
1007           * NOTE         for 1BP/ROM Font
1008           */
1009          void tw_icons_color_change(struct tw_icons* picon, unsigned char color)
1010          {
1011   1        _icons_draw_at(picon->table, color, picon->x, picon->y, picon->width, picon->height, CUR_MENU_P->addr, CU
             -R_MENU_P->width, (SUPPORT_1BP_ROM?picon->offset:0), 0);
1012   1      }
1013          
1014          /*
1015           * Synopsis     void tw_icons_1st_color(struct tw_icons* picon);
1016           * Description  change to 1st color of ICONS      O定icons榈谝唤M色P
1017           * Parameters   *tw_icons - point of icon struct    icons物件??
1018           * Return       none
C51 COMPILER V7.50   TW_WIDGET_SYS                                                         06/16/2017 08:24:38 PAGE 18  

1019           * NOTE         for 2BP/4BP Font
1020           */
1021          void tw_icons_1st_color(struct tw_icons* picon)
1022          {
1023   1        tw_icons_draw(picon);
1024   1      }
1025          
1026          /*
1027           * Synopsis     void tw_icons_2nd_color(struct tw_icons* picon);
1028           * Description  change to 2nd color of ICONS      O定icons榈诙M色P
1029           * Parameters   *tw_icons - point of icon struct    icons物件??
1030           * Return       none
1031           * NOTE         for 2BP/4BP Font
1032           */
1033          void tw_icons_2nd_color(struct tw_icons* picon)
1034          {
1035   1        _icons_draw_at(picon->table, ((picon->color)>>4), picon->x, picon->y, picon->width, picon->height, CUR_ME
             -NU_P->addr, CUR_MENU_P->width, (SUPPORT_1BP_ROM?picon->offset:0), 0);
1036   1      }
1037          
1038          /*
1039           * Synopsis     void tw_gicons_draw(struct tw_gicons* pgicons);
1040           * Description  show ICON(OSD2)             @示icon於menu上
1041           * Parameters   *tw_icon  - point of icon struct    icon物件指
1042           * Return       none
1043           * NOTE         OSD2 need init and load data (tw_menu_draw) before the show ICON
1044           */
1045          void tw_gicons_draw(struct tw_gicons* pgicon)
1046          {
1047   1        unsigned char icon_id = 0;
1048   1        unsigned short tmp_addr = 0;
1049   1        
1050   1          icon_id = check_gicon_id(pgicon->gicons_id);
1051   1          if(!icon_id)
1052   1              return;
1053   1          
1054   1          tmp_addr = pgicon->oram_addr;
1055   1          /* dynamic load ICON to OSDRAM */
1056   1          tw_load_icon(icon_id, &tmp_addr);
1057   1      
1058   1        _icons_draw(pgicon->x, pgicon->y, pgicon->width, pgicon->height, pgicon->table, 
1059   1              pgicon->color, (SUPPORT_1BP_ROM?pgicon->offset:0), 0);
1060   1      }
1061          
1062          /*
1063           * Synopsis     void tw_icons_draw(struct tw_icons* picon);
1064           * Description  show ICONS(OSD2)            @示icons於menu上
1065           * Parameters   *tw_icons - point of icon struct    icons物件指
1066           * Return       none
1067           * NOTE         OSD2 need init and load data (tw_menu_draw) before the show ICONS
1068           */
1069          void tw_icons_draw(struct tw_icons* picon)
1070          {
1071   1        _icons_draw(picon->x, picon->y, picon->width, picon->height, picon->table, 
1072   1              picon->color, (SUPPORT_1BP_ROM?picon->offset:0), 0);
1073   1      }
1074          
1075          #define FONT_ASCII_OFFSET 10
1076          void _romfont_draw_at(struct tw_txt* ptxt, unsigned char x, unsigned char y, const unsigned char *ucs, uns
             -igned short menu_addr, unsigned char menu_width, unsigned char color, unsigned char blink)
1077          {
1078   1        unsigned char i;
C51 COMPILER V7.50   TW_WIDGET_SYS                                                         06/16/2017 08:24:38 PAGE 19  

1079   1        unsigned short temp= 0;
1080   1        
1081   1        if(blink)
1082   1          color |= 0x20;
1083   1                    
1084   1          osd_set_location_addr(x, y, menu_addr, menu_width);
1085   1        
1086   1        for(i=0; (ucs[i]!=0) && (i < 255); i++) {
1087   2          if((x+i)>=CUR_MENU_P->width) 
1088   2            break;
1089   2          if(i>=ptxt->width)
1090   2            break;
1091   2          temp = (color<<9);
1092   2          if(ucs[i]==' ') //BLANK
1093   2            OSD_SET_RAM_DATA(temp);
1094   2          else if(ucs[i]=='^') {
1095   3            temp |= (ucs[i]+ptxt->index+2-FONT_ASCII_OFFSET);
1096   3            OSD_SET_RAM_DATA(temp);
1097   3          } else {
1098   3            temp |= (ucs[i]+ptxt->index-FONT_ASCII_OFFSET);
1099   3            OSD_SET_RAM_DATA(temp);
1100   3          }
1101   2        }  
1102   1      }
1103          
1104          void _romfont_draw(struct tw_txt* ptxt, unsigned char x, unsigned char y, const unsigned char *ucs, unsign
             -ed char color, unsigned char blink)
1105          {             
1106   1          _romfont_draw_at(ptxt, x, y, ucs, CUR_MENU_P->addr, CUR_MENU_P->width, color, blink);  
1107   1      }
1108          
1109          void tw_romfont_draw(struct tw_txt* ptxt, const unsigned char *ucs)
1110          {             
1111   1          _romfont_draw_at(ptxt, ptxt->x, ptxt->y, ucs, CUR_MENU_P->addr, CUR_MENU_P->width, ((ptxt->fg_color)<<
             -0) + ((ptxt->bg_color)<<5), 0);  
1112   1      }
1113           
1114          
1115          /* T123 OSD Font Drawing Info Table         24x24 32x31 32x36 48x48(16x24) 48x48(12x24)  rev */
1116          unsigned short code TOF_FONT_SPLIT_W[]    = { 2,    2,    2,    3,           4,           1};
1117          unsigned short code TOF_FONT_SPLIT_H[]    = { 1,    1,    2,    2,           2,           2};
1118          unsigned short code TOF_FONT_SPLIT_HSA[]  = { 1,    1,    1,    2,           2,           1};
1119          
1120          #define SINGLE_PIX 0
1121          #define SUB_PIX    1 
1122          
1123          #define GB_ERROR_CODE 0xFFFF
1124          
1125          unsigned char _tw_half_alphabet_num()
1126          {
1127   1        return spi_read_byte(CUR_TOF_RES.base_addr + 0x54L);
1128   1      }
1129          
1130          unsigned char _tw_get_font_size_id()
1131          {
1132   1        return spi_read_byte(CUR_TOF_RES.base_addr + 0x55L);  
1133   1      }
1134          
1135          unsigned char _tw_get_file_type() {
1136   1        return spi_read_byte(CUR_TOF_RES.base_addr + 0x01L);
1137   1      }
1138          
C51 COMPILER V7.50   TW_WIDGET_SYS                                                         06/16/2017 08:24:38 PAGE 20  

1139          unsigned short _Unicode_len(unsigned short *ucs) {
1140   1          unsigned short i;
1141   1      
1142   1        for(i=0; ucs[i]!= 0 && i<0xffff; i++) { 
1143   2        }
1144   1      
1145   1        return i;
1146   1      }
1147          
1148          unsigned short _GB_code_len(unsigned short *ucs) {
1149   1        unsigned char *gbs = ucs;
1150   1        unsigned short len = 0;
1151   1        int i;
1152   1      
1153   1        for(i=0, len=0; gbs[i]!=0 && len<GB_ERROR_CODE; len++) {
1154   2          if(gbs[i] >= 0xA1) { 
1155   3            if(gbs[i+1] < 0xA0) {
1156   4              len = GB_ERROR_CODE - 1;
1157   4            }
1158   3            i+=2;
1159   3          }
1160   2          else {  
1161   3            i++;
1162   3          }   
1163   2        }
1164   1      
1165   1        if(len == GB_ERROR_CODE) { 
1166   2          ERROR(("Fail To Get GB String Length!\n"));
1167   2        }
1168   1           
1169   1        return len;
1170   1      }
1171          
1172          unsigned short _get_offset_GBS(unsigned short *ucs, unsigned short n) {  
1173   1        unsigned char *gbs = ucs;
1174   1        int i, idx;
1175   1      
1176   1        for(i=0, idx = 0;  gbs[idx]!=0 && i<0xFFFF; i++) { 
1177   2          if(i == n) {
1178   3            break;  
1179   3          }
1180   2          if(gbs[idx] >= 0xA1) {  
1181   3            idx+=2;
1182   3          }
1183   2          else {
1184   3            idx++;
1185   3          }   
1186   2        }
1187   1        
1188   1        if(i == 0xFFFF) {  
1189   2          idx = GB_ERROR_CODE;
1190   2          ERROR(("Fail To Get GB String Offset!\n"));
1191   2        }   
1192   1      
1193   1        return idx;
1194   1      }
1195          
1196          unsigned short _get_code_from_GBS(unsigned short *ucs, unsigned short n) {   
1197   1        unsigned char *gbs = ucs;
1198   1        unsigned short cod = GB_ERROR_CODE;
1199   1        int i, idx;
1200   1      
C51 COMPILER V7.50   TW_WIDGET_SYS                                                         06/16/2017 08:24:38 PAGE 21  

1201   1        for(i=0, idx=0; gbs[idx]!=0 && i<0xFFFF; i++) { 
1202   2          if(i == n) {
1203   3            if(gbs[idx] >= 0xA1) {  
1204   4              cod = gbs[idx+1L];
1205   4              cod += (gbs[idx]<<8L);
1206   4            }
1207   3            else {        
1208   4              cod = gbs[idx];
1209   4            } 
1210   3            break;  
1211   3          }
1212   2          if(gbs[idx] >= 0xA1) {  
1213   3            idx+=2;
1214   3          }
1215   2          else {
1216   3            idx++;
1217   3          }   
1218   2        }
1219   1        
1220   1        if(cod == GB_ERROR_CODE) {
1221   2          ERROR(("Fail To Get GB Code!\n"));
1222   2        }   
1223   1      
1224   1        return cod;
1225   1      }
1226          
1227          
1228          unsigned char _tw_get_font_quality()
1229          { 
1230   1        return spi_read_byte(CUR_TOF_RES.base_addr + 0x50L);
1231   1      }
1232          
1233          
1234          void _twfont_draw_at(struct tw_txt* ptxt, unsigned char x, unsigned char y, unsigned short *ucs, unsigned 
             -short menu_addr, unsigned char menu_width, unsigned char color, unsigned char blink)
1235          {
1236   1        unsigned char size_id, font_quality;  
1237   1                       
1238   1        font_quality = _tw_get_font_quality();
1239   1        size_id      = _tw_get_font_size_id();  
1240   1        tw_menu_reset_index_n(ptxt->index); 
1241   1        tw_menu_draw_nstring(x, y, ptxt->width, ucs, menu_addr, menu_width, (blink?(color|0x20):color), size_id, 
             -font_quality!=SINGLE_PIX);    
1242   1      }
1243          
1244          #define TOF_DIST_ERROR_CODE              0
1245          #define TOF_DIST_BASIC_LATIN_START_CODE  0x0021 
1246          #define TOF_DIST_BASIC_LATIN_END_CODE    0x007F
1247                                   
1248          #define TOF_DIST_LATIN_1_START_CODE      0x00A1
1249          #define TOF_DIST_LATIN_1_END_CODE        0x00FF
1250          
1251          #define TOF_DIST_CYRILLIC_START_CODE     0x0400
1252          #define TOF_DIST_CYRILLIC_END_CODE       0x051D
1253          
1254          unsigned short _check_and_get_idx(unsigned short uc) {
1255   1        if(uc >= TOF_DIST_BASIC_LATIN_START_CODE && uc <= TOF_DIST_BASIC_LATIN_END_CODE)
1256   1          return uc - TOF_DIST_BASIC_LATIN_START_CODE;
1257   1        else
1258   1          return TOF_DIST_ERROR_CODE;                           
1259   1      }
1260          
C51 COMPILER V7.50   TW_WIDGET_SYS                                                         06/16/2017 08:24:38 PAGE 22  

1261          void _twfont_2bppic_st_draw_at(struct tw_txt* ptxt, unsigned char x, unsigned char y, unsigned short *ucs,
             - unsigned short menu_addr, unsigned char menu_width, unsigned char color)
1262          {
1263   1        unsigned char i, j;
1264   1        unsigned short index;
1265   1        unsigned char draw_offset = 0;
1266   1      
1267   1        for(i=0; i<ptxt->height; i++) {
1268   2          for(j=0; j<ptxt->width && ucs[draw_offset]!= 0; j++, draw_offset++) { 
1269   3            index = _check_and_get_idx(ucs[draw_offset]) + ptxt->index;                      
1270   3            osd_menu_write(x+j, y+i, index, color, menu_addr, menu_width);  
1271   3          }    
1272   2        }
1273   1      }
1274            
1275          #define ID_TEXT_ROM          0  
1276          #define ID_TEXT_PIC_2BP 0xFFFF  
1277          //#define ID_TEXT_TOF_2BP 0xFFFE   
1278          //#define ID_TEXT_TOF_1BP    1  
1279          
1280          void _twfont_draw(struct tw_txt* ptxt, unsigned char x, unsigned char y, unsigned short *ucs, unsigned cha
             -r color, unsigned char blink)
1281          { 
1282   1        if(ptxt->icon_id == ID_TEXT_PIC_2BP)
1283   1          _twfont_2bppic_st_draw_at(ptxt, x, y, ucs, CUR_MENU_P->addr, CUR_MENU_P->width, ((ptxt->fg_color)<<1)); 
1284   1        else
1285   1          _twfont_draw_at(ptxt, x, y, ucs, CUR_MENU_P->addr, CUR_MENU_P->width, color, blink);    
1286   1      }
1287          
1288          void tw_twfont_draw(struct tw_txt* ptxt, unsigned short *ucs)
1289          {    
1290   1        if(ptxt->icon_id == ID_TEXT_PIC_2BP)
1291   1          _twfont_2bppic_st_draw_at(ptxt, ptxt->x, ptxt->y, ucs, CUR_MENU_P->addr, CUR_MENU_P->width, ((ptxt->fg_c
             -olor)<<0));    
1292   1        else
1293   1          _twfont_draw_at(ptxt, ptxt->x, ptxt->y, ucs, CUR_MENU_P->addr, CUR_MENU_P->width, ((ptxt->fg_color)<<0) 
             -+ ((ptxt->bg_color)<<5), 0);    
1294   1      }
1295          
1296          unsigned char _tw_draw_char_at(unsigned char x, unsigned char y, unsigned char w, unsigned h, 
1297                            unsigned short idx, unsigned char color, unsigned short menu_addr, unsigned char menu_width)
1298          {
1299   1        unsigned char i, j;
1300   1      
1301   1        for(j=0; j<w; j++) {  
1302   2          for(i=0; i<h; i++) {
1303   3            osd_menu_write(x+j, y+i, idx+i+j*h, color, menu_addr, menu_width);      
1304   3          }
1305   2        }
1306   1      
1307   1        return w*h;
1308   1      }
1309          
1310          void _tw_burst_draw_line(unsigned char x, unsigned char y, unsigned char w, unsigned h, 
1311                            unsigned short idx, unsigned char color, unsigned short menu_addr, unsigned char menu_width)
1312          {
1313   1        unsigned char i, j;
1314   1        unsigned short dat;
1315   1                    
1316   1        for(i=0; i<h; i++) {    
1317   2          osd_set_location_addr(x, y+i, menu_addr, menu_width);
1318   2          for(j=0; j<w; j++) { 
C51 COMPILER V7.50   TW_WIDGET_SYS                                                         06/16/2017 08:24:38 PAGE 23  

1319   3            dat = (color<<9) + idx + j*h + i; 
1320   3            OSD_SET_RAM_DATA(dat);  
1321   3          }
1322   2        }
1323   1      }
1324          
1325          unsigned short tw_menu_draw_nstring(unsigned char x, unsigned char y, unsigned char max_w, const unsigned 
             -short *ucs, unsigned short menu_addr, unsigned char menu_width, 
1326                                                 unsigned char color, unsigned char size_id, unsigned char is2BP)
1327          {
1328   1        unsigned short i;
1329   1        unsigned short font_size;  
1330   1        unsigned char is_hsa = (_tw_half_alphabet_num() > 0);
1331   1        unsigned short real_oaddr;
1332   1        unsigned char bp = is2BP ? 2 : 1;
1333   1      
1334   1        unsigned char is_gb = ((_tw_get_file_type()=='G') ? 1 : 0);   
1335   1        unsigned short len = ((is_gb) ? _GB_code_len(ucs) : _Unicode_len(ucs));
1336   1        unsigned short uc;
1337   1          
1338   1        unsigned char w_count = 0;
1339   1        unsigned char w_sum = 0;
1340   1        unsigned short temp_idx = menu_string_start_index;
1341   1      
1342   1        font_size = (CUR_MENU_P->font_w*CUR_MENU_P->font_h)/16;
1343   1                
1344   1          for(i=0; (i<len)&&(w_sum<=max_w); i++) { 
1345   2          uc = ((is_gb) ? _get_code_from_GBS(ucs, i) : ucs[i]);
1346   2          real_oaddr = (is2BP) ? (CUR_2BP_IDX*font_size + (menu_string_start_index-CUR_2BP_IDX)*font_size*2) : fon
             -t_size*menu_string_start_index;  
1347   2            if(is_hsa) {
1348   3            w_count = osd_put_twf_char_to_oram(CUR_TOF_RES.base_addr, real_oaddr, uc, TOF_FONT_SPLIT_H[size_id]*fon
             -t_size*2*bp, is_hsa);  
1349   3            menu_string_start_index += w_count* TOF_FONT_SPLIT_H[size_id]; 
1350   3            w_sum += w_count; 
1351   3          }
1352   2          else {                                           
1353   3            osd_put_twf_char_to_oram(CUR_TOF_RES.base_addr, real_oaddr, uc, font_size*TOF_FONT_SPLIT_W[size_id]*TOF
             -_FONT_SPLIT_H[size_id]*2*bp, is_hsa); 
1354   3            menu_string_start_index += TOF_FONT_SPLIT_W[size_id]*TOF_FONT_SPLIT_H[size_id]; 
1355   3            w_sum += TOF_FONT_SPLIT_W[size_id];
1356   3          }
1357   2        }
1358   1        
1359   1        if(w_sum > max_w) {
1360   2          w_sum = max_w;
1361   2        } 
1362   1              
1363   1        _tw_burst_draw_line(x, y, w_sum, TOF_FONT_SPLIT_H[size_id], temp_idx, color, menu_addr, menu_width);
1364   1        
1365   1        return i; 
1366   1      }
1367          
1368          void tw_menu_row_moveV(unsigned char row, unsigned short y)
1369          {
1370   1        unsigned short dat = 0x4000 + y;
1371   1        unsigned short address = CUR_MENU_P->addr + ((CUR_MENU_P->width + 4) * row); 
1372   1                              
1373   1        IC_WRITBYTE(0x00, 0xAA, (unsigned char)(address & 0xff));
1374   1        IC_WRITBYTE(0x00, 0xAA, (unsigned char)(address>>8));
1375   1                
1376   1        //osd_set_location_addr(x, y, MENU_BASE_ADDRESS_TBL[CUR_PAGE_ID-1][1], CUR_MENU_P->width);
C51 COMPILER V7.50   TW_WIDGET_SYS                                                         06/16/2017 08:24:38 PAGE 24  

1377   1        osd_set_ram_data(dat);
1378   1      }
1379          
1380          void tw_menu_reset_index()
1381          {
1382   1        menu_string_start_index = 0;
1383   1      }
1384          
1385          void tw_menu_reset_index_n(unsigned short idx)
1386          {
1387   1        menu_string_start_index = idx;  
1388   1      }
1389          
1390          void tw_menu_reset_index_rev_nums()
1391          {
1392   1        menu_string_start_index = 20; 
1393   1      }
1394          
1395          void tw_menu_nums_init()
1396          {
1397   1        unsigned char i;
1398   1        unsigned short font_size;
1399   1      
1400   1        font_size = CUR_TOF_RES.font_width*CUR_TOF_RES.font_height/16;
1401   1                    
1402   1          for(i=0; i<10; i++) {  
1403   2          osd_put_twf_char_to_oram(CUR_TOF_RES.base_addr, font_size*i, i+48, font_size*2, 0); 
1404   2        }
1405   1        menu_string_start_index = 20;  
1406   1        
1407   1      }
1408           
1409          /*
1410           * Synopsis     void tw_text_draw(struct tw_txt* ptxt, unsigned short *ucs);
1411           * Description  show ICON(OSD2)               Lutxt至menu
1412           * Parameters   *ptxt - point of txt struct       txt物件指
1413           *              *ucs  - start point of string (utf-8)   字串指(utf-8) 
1414           * Return       none
1415           * NOTE         OSD2 need init and load data (tw_menu_draw) before the show text
1416           *              text types include twfont and ROMFont
1417           */
1418          void tw_text_draw(struct tw_txt* ptxt, unsigned short *ucs)
1419          {
1420   1      //#ifndef ENABLE_EX_MCU
1421   1      //  IC_WritByte(TWIC_P1,0xFE,0xAD);
1422   1      //#endif
1423   1          
1424   1        if(ptxt->icon_id==0) {
1425   2          /* ROM FONT */
1426   2          tw_romfont_draw(ptxt, (unsigned char*)ucs);
1427   2        } else {
1428   2          /* TWFONT */
1429   2          tw_twfont_draw(ptxt, ucs);  
1430   2        }
1431   1      //#ifndef ENABLE_EX_MCU
1432   1      //  IC_WritByte(TWIC_P1,0xFE,0xA5);
1433   1      //#endif  
1434   1      }
1435          
1436          /*
1437           * Synopsis     void tw_text_color_change(struct tw_txt* ptxt,
1438           *                                      unsigned short *ucs,
C51 COMPILER V7.50   TW_WIDGET_SYS                                                         06/16/2017 08:24:38 PAGE 25  

1439           *                    unsigned char color);
1440           * Description  change color index of ICONS         切Q字型之色P??
1441           * Parameters   *ptxt - point of txt struct       txt物件指
1442           *              *ucs  - start point of string (utf-8)   字串指(utf-8)
1443           *        color - want to change of color index   欲切Q之色P??
1444           * Return       none
1445           * NOTE         for text (1BP/ROM Font)
1446           */
1447          void tw_text_color_change(struct tw_txt* ptxt, unsigned short *ucs, unsigned char color)
1448          {
1449   1        if(ptxt->icon_id==0) {
1450   2          /* ROM FONT */
1451   2          _romfont_draw(ptxt, ptxt->x, ptxt->y, (unsigned char*)ucs, color, 0);  
1452   2        } else {
1453   2          /* TWFONT */
1454   2          _twfont_draw(ptxt, ptxt->x, ptxt->y, ucs, color, 0);    
1455   2        }
1456   1      }
1457          
1458          /*
1459           * Synopsis     void tw_osd_menu_write(unsigned char x,
1460           *                  unsigned char y,
1461           *                  unsigned short index,
1462           *                  unsigned char color);
1463           * Description  writting are font index and color index at OSD2-MENU(OSD RAM) (advanced application)  ?入字
             -型/色P??至mrenu特定位置(MA函)
1464           * Parameters   x   - x of coordinate of OSD2-MENU (unit is font)   xS位置 (tile)
1465           *              y   - y of coordinate of OSD2-MENU (unit is font)   yS位置 (tile)
1466           *              index - font of index                   tile ?? 
1467           *              color - color of index                  色P ??
1468           * Return       none
1469           */
1470          void tw_osd_menu_write(unsigned char x, unsigned char y, unsigned short index, unsigned char color)
1471          {
1472   1        osd_menu_write(x, y, index, color, CUR_MENU_P->addr, CUR_MENU_P->width);  
1473   1      }
1474          
1475          /*
1476           * Synopsis     void tw_osd_menu_write_line(unsigned char y,
1477           *                  unsigned short index,
1478           *                  unsigned char color);
1479           * Description  writting are font index and color index at OSD2-MENU(OSD RAM) ?入字型/色P??至menu特定行(
             -MA函) 
1480           *              and a line (menu_width)
1481           * Parameters   y   - y of coordinate of OSD2-MENU (unit is font) yS位置(tile)
1482           *              index - font of index                 tile ??
1483           *              color - color of index                色P ??
1484           * Return       none
1485           */
1486          void tw_osd_menu_write_line(unsigned char y, unsigned short index, unsigned char color)
1487          {
1488   1        osd_menu_write_line(y, index, color, CUR_MENU_P->addr, CUR_MENU_P->width);
1489   1      }
1490          
1491          /*
1492           * Synopsis     void tw_osd_clear_line(unsigned char y);
1493           * Description  clear(writting a 0) a line (menu_width) at OSD2-MENU(OSD RAM) 清除menu特定行
1494           * Parameters   y - y of coordinate of OSD2-MENU (unit is font)       yS位置(tile)
1495           * Return       none
1496           * NOTE         default(must) blank font of index is 0
1497           */
1498          void tw_osd_clear_line(unsigned char y)
C51 COMPILER V7.50   TW_WIDGET_SYS                                                         06/16/2017 08:24:38 PAGE 26  

1499          {
1500   1        osd_clear_line(y, CUR_MENU_P->addr, CUR_MENU_P->width);
1501   1      }
1502          
1503          /*
1504           * Synopsis     void tw_osd_clear_char(unsigned char x, unsigned char y);
1505           * Description  clear(writting a 0) a char at OSD2-MENU(OSD RAM)    清除menu特定tile
1506           * Parameters   x - x of coordinate of OSD2-MENU (unit is font)   xS位置(tile)
1507           *              y - y of coordinate of OSD2-MENU (unit is font)   yS位置(tile)
1508           * Return       none
1509           * NOTE         default(must) blank font of index is 0
1510           *              just clear to blank font (LSB), no clear color index (MSB)
1511           */
1512          void tw_osd_clear_char(unsigned char x, unsigned char y)
1513          {
1514   1        //osd_clear_char(x, y, CUR_MENU_P->addr, CUR_MENU_P->width);
1515   1        osd_clear_block(x, y, 1, 1, CUR_MENU_P->addr, CUR_MENU_P->width);
1516   1      }
1517          
1518          /*
1519           * Synopsis     void tw_clear_icon(struct tw_icon* picon);
1520           * Description  clear(writting a 0) a ICON at OSD2-MENU(OSD RAM)  清除menu上某icon
1521           * Parameters   *tw_icon    - point of icon struct          icon物件指
1522           * Return       none
1523           * NOTE         default(must) blank font of index is 0
1524           */
1525          void tw_clear_icon(struct tw_icon* picon) {
1526   1        osd_clear_block(picon->x, picon->y, picon->width, picon->height, CUR_MENU_P->addr, CUR_MENU_P->width);
1527   1      }
1528          
1529          /*
1530           * Synopsis     void tw_clear_icons(struct tw_icons* picon);
1531           * Description  clear(writting a 0) a ICONS at OSD2-MENU(OSD RAM) 清除menu上某icons
1532           * Parameters   *tw_icons    - point of icons struct        icons物件指
1533           * Return       none
1534           * NOTE         default(must) blank font of index is 0
1535           */
1536          void tw_clear_icons(struct tw_icons* picon) {
1537   1        osd_clear_block(picon->x, picon->y, picon->width, picon->height, CUR_MENU_P->addr, CUR_MENU_P->width);
1538   1      }
1539          
1540          /*
1541           * Synopsis     void tw_clear_txt(struct tw_txt* ptxt);
1542           * Description  clear(writting a 0) a txt at OSD2-MENU(OSD RAM) 清除menu上某txt
1543           * Parameters   *ptxt   - point of txt struct         txt物件指
1544           * Return       none
1545           * NOTE         default(must) blank font of index is 0
1546           */
1547          void tw_clear_txt(struct tw_txt* ptxt) {
1548   1        osd_clear_block(ptxt->x, ptxt->y, ptxt->width, ptxt->height, CUR_MENU_P->addr, CUR_MENU_P->width);
1549   1      }
1550          
1551          /*
1552           * Synopsis     void _tw_clear_icon_at(struct tw_icon* picon,
1553           *                                  unsigned short menu_addr,
1554           *                                  unsigned char menu_width);
1555           * Description  clear(writting a 0) a ICON at OSD2-MENU(OSD RAM) (advanced application)   清除menu上某icon(
             -MA函式)
1556           * Parameters   *picon    - point of icon struct          icon物件指
1557           *              menu_addr - base address of OSD2-MENU       menu oram 地址
1558           *              menu_width  - width of OSD2-MENU (unit is font)   menu ?度(tile)
1559           * Return       none
C51 COMPILER V7.50   TW_WIDGET_SYS                                                         06/16/2017 08:24:38 PAGE 27  

1560           * NOTE         default(must) blank font of index is 0
1561           *              can assigned base address and width of OSD2-MENU
1562           */
1563          void _tw_clear_icon_at(struct tw_icon* picon, unsigned short menu_addr, unsigned char menu_width) {
1564   1        osd_clear_block(picon->x, picon->y, picon->width, picon->height, menu_addr, menu_width);
1565   1      }
1566          
1567          /*
1568           * Synopsis     void _tw_clear_icons_at(struct tw_icons* picons,
1569           *                                  unsigned short menu_addr,
1570           *                                  unsigned char menu_width);
1571           * Description  clear(writting a 0) a ICONS at OSD2-MENU(OSD RAM) (advanced application)  清除menu上某icons
             -(MA函式)
1572           * Parameters   *picons    - point of icons struct          icons物件指
1573           *              menu_addr - base address of OSD2-MENU       menu oram 地址
1574           *              menu_width  - width of OSD2-MENU (unit is font)   menu ?度(tile)
1575           * Return       none
1576           * NOTE         default(must) blank font of index is 0
1577           *              can assigned base address and width of OSD2-MENU
1578           */
1579          void _tw_clear_icons_at(struct tw_icons* picon, unsigned short menu_addr, unsigned char menu_width) {
1580   1        osd_clear_block(picon->x, picon->y, picon->width, picon->height, menu_addr, menu_width);
1581   1      }
1582          
1583          /*
1584           * Synopsis     void _tw_clear_txt_at(struct tw_txt* ptxt,
1585           *                                  unsigned short menu_addr,
1586           *                                  unsigned char menu_width);
1587           * Description  clear(writting a 0) a txt at OSD2-MENU(OSD RAM) (advanced application)  清除menu上某txt(M
             -A函式)
1588           * Parameters   *ptxt       - point of txt struct         txt物件指
1589           *              menu_addr - base address of OSD2-MENU       menu oram 地址
1590           *              menu_width  - width of OSD2-MENU (unit is font)   menu ?度(tile)
1591           * Return       none
1592           * NOTE         default(must) blank font of index is 0
1593           *              can assigned base address and width of OSD2-MENU
1594           */
1595          void _tw_clear_txt_at(struct tw_txt* ptxt, unsigned short menu_addr, unsigned char menu_width) {
1596   1        osd_clear_block(ptxt->x, ptxt->y, ptxt->width, ptxt->height, menu_addr, menu_width);
1597   1      }
1598          
1599          /*
1600           * Synopsis     void tw_osd_clear_menu(void);
1601           * Description  clear all char(0) at OSD2-MENU(OSD RAM)   清除menu
1602           * Parameters   none
1603           * Return       none
1604           * NOTE         default(must) blank font of index is 0
1605           */
1606          void tw_osd_clear_menu(void)
1607          {
1608   1        osd_clear_menu(CUR_MENU_P->addr, CUR_MENU_P->width, CUR_MENU_P->height);
1609   1      }
1610          
1611          /*
1612           * Synopsis     void tw_menu_fill(unsigned char x,
1613           *                                unsigned char y,
1614           *                                unsigned char dat,
1615           *                                unsigned char color,
1616           *                                unsigned char length);
1617           * Description  fill a block include dat(LSB)&color(MSB) at OSD2-MENU(OSD RAM)
1618           * Parameters   x   - x of coordinate of OSD2-MENU (unit is font)
1619           *              y   - y of coordinate of OSD2-MENU (unit is font)
C51 COMPILER V7.50   TW_WIDGET_SYS                                                         06/16/2017 08:24:38 PAGE 28  

1620           *              dat   - font of index
1621           *              color - color of index
1622           *              length  - fill data of length
1623           * Return       none
1624           * NOTE         default(must) blank font of index is 0
1625           */
1626          void tw_menu_fill(unsigned char x, unsigned char y, unsigned char dat, unsigned char color, unsigned char 
             -length)
1627          {
1628   1        unsigned char i;
1629   1      
1630   1        for(i=0; i< length; i++) {
1631   2          osd_menu_write(x+i, y, dat, color, CUR_MENU_P->addr, CUR_MENU_P->width);    
1632   2        }    
1633   1      }
1634          
1635          /*
1636           * Synopsis     void tw_emu_trig(void);
1637           * Description  emulation trig
1638           * Parameters   none
1639           * Return       none
1640           * NOTE         need load emulation (tw_load_emu) before
1641           */
1642          void tw_emu_trig(void)
1643          {
1644   1        IC_WritByte (TWIC_P0, SHADOW_CTRL_CONF_REG, SHADOW_CTRL_ENABLE);  // for SPIOSD shadow issue
1645   1        sosd_emu_trig();
1646   1      }
1647          
1648          /*
1649           * Synopsis     void tw_load_emu(unsigned short id);
1650           * Description  setting registers for emulation
1651           * Parameters   id  - emulation script of resource ID
1652           * Return       none
1653           */
1654          void tw_load_emu(unsigned short id)
1655          {
1656   1        char rc= 0;
1657   1        struct res_emu_t emu_s;
1658   1        
1659   1      #ifdef TW_WG_DEBUG_MODE
                show_resource_header(id);
              #endif  
1662   1        
1663   1        get_res_emu(id, &emu_s);
1664   1        
1665   1        tw_emu_exit();
1666   1      
1667   1        sosd_set_emu_base_addrss(emu_s.base_addr);
1668   1        tw_emu_trig();
1669   1      }
1670          
1671          /*
1672           * Synopsis     void tw_emu_trig(void);
1673           * Description  waitting emulation script done
1674           * Parameters   none
1675           * Return       none
1676           * NOTE         some emulation scripts was always run, ex. animation,
1677           *              these emulation should force exit (tw_emu_exit) by fw.
1678           */
1679          void tw_wait_emu_done(void)
1680          {
C51 COMPILER V7.50   TW_WIDGET_SYS                                                         06/16/2017 08:24:38 PAGE 29  

1681   1        sosd_wait_emu_done();
1682   1        IC_WritByte (TWIC_P0, SHADOW_CTRL_CONF_REG, SHADOW_CTRL_DISABLE); // for SPIOSD shadow issue
1683   1      }
1684          
1685          /*
1686           * Synopsis     void tw_emu_exit(void);
1687           * Description  force exit from emulation script
1688           * Parameters   none
1689           * Return       none
1690           */
1691          void tw_emu_exit(void)
1692          {
1693   1        sosd_emu_exit();
1694   1        IC_WritByte (TWIC_P0, SHADOW_CTRL_CONF_REG, SHADOW_CTRL_DISABLE); // for SPIOSD shadow issue
1695   1      }
1696          
1697          /*
1698           * Synopsis     void tw_img_force_alpha(unsigned char en);
1699           * Description  force image/twbc (SPIOSD) of alpha
1700           * Parameters   en  - 0/1: disable/enable force alpha
1701           * Return       none
1702           */
1703          void tw_img_force_alpha(unsigned char en)
1704          {
1705   1        if(en) {
1706   2          sosd_img_force_ctrl(64);
1707   2          sosd_img_force_enable();
1708   2        } else
1709   1          sosd_img_force_disable();
1710   1      }
1711          
1712          /*
1713           * Synopsis     void put_enter_page_event(unsigned char id);
1714           * Description  put a enter page ID of event to event queue
1715           * Parameters   id  - page of resource ID
1716           * Return       none
1717           */
1718          void put_enter_page_event(unsigned char id)
1719          {         
1720   1        TW_EVENT events;            
1721   1        events.type = TW_EVENT_TYPE_ENTER_SYSTEM;
1722   1        events.page.id = id;
1723   1        events.page.mode = PAGE_EVENT_NORMAL;
1724   1        put_event(&events);
1725   1      }
1726          
1727          /*
1728           * Synopsis     void put_quit_page_event(unsigned char id);
1729           * Description  put a quit page ID of event to event queue    插入"x_?面事件"M入事件堆B
1730           * Parameters   id  - page of resource ID           ?面ID
1731           * Return       none
1732           */
1733          void put_quit_page_event(unsigned char id)
1734          {
1735   1        TW_EVENT events;
1736   1        events.type = TW_EVENT_TYPE_QUIT_SYSTEM;
1737   1        events.page.id = id;
1738   1        events.page.mode = PAGE_EVENT_NORMAL;
1739   1        put_event(&events);
1740   1      }
1741          
1742          /*
C51 COMPILER V7.50   TW_WIDGET_SYS                                                         06/16/2017 08:24:38 PAGE 30  

1743           * Synopsis     void put_enter_slide_page_event(unsigned char id);
1744           * Description  put a enter page ID of event to event queue   插入"滑舆M入?面事件"M入事件堆B   
1745           * Parameters   id  - page of resource ID           ?面ID
1746           * Return       none
1747           * NOTE         enter page of type is slide for touch slide
1748           */
1749          void put_enter_slide_page_event(unsigned char id)
1750          {         
1751   1        TW_EVENT events;            
1752   1        events.type = TW_EVENT_TYPE_ENTER_SYSTEM;
1753   1        events.page.id = id;
1754   1        events.page.mode = PAGE_EVENT_SLIDE;
1755   1        put_event(&events);
1756   1      }
1757          
1758          /*
1759           * Synopsis     void put_enter_slide_page_event(unsigned char id);
1760           * Description  put a quit page ID of event to event queue    插入"滑与x_?面事件"M入事件堆B
1761           * Parameters   id  - page of resource ID           ?面ID
1762           * Return       none
1763           * NOTE         quit page of type is slide for touch slide
1764           */
1765          void put_quit_slide_page_event(unsigned char id)
1766          {
1767   1        TW_EVENT events;
1768   1        events.type = TW_EVENT_TYPE_QUIT_SYSTEM;
1769   1        events.page.id = id;
1770   1        events.page.mode = PAGE_EVENT_SLIDE;
1771   1        put_event(&events);
1772   1      }
1773          
1774          /*
1775           * Synopsis     unsigned char tw_page_process(TW_EVENT* event);
1776           * Description  call a process function (current of page ID) to processing events 呼叫目前?面之?理函式 
1777           * Parameters   event - events (all events) of tw widget system         ?面系y送出之事件
1778           * Return       0: none           ]事
1779           *              1: not page         此ID非?面
1780           *              2: no active page     目前o\作中?面
1781           *              3: no process any event   ?面f置
1782           *              4: no page          目前IDo?面
1783           */
1784          unsigned char tw_page_process(TW_EVENT* event)
1785          {
1786   1        if(event->type==TW_EVENT_TYPE_ENTER_SYSTEM) {
1787   2          CUR_PAGE_ID = event->page.id;
1788   2        } 
1789   1        if(CUR_PAGE_ID==0xFF) {
1790   2          dbg(3, ("no active page!\n"));
1791   2          return TW_RETURN_NO_ACTIVE; 
1792   2        }
1793   1        
1794   1        return tw_page_handler(CUR_PAGE_ID, event);
1795   1      }
1796          
1797          /*
1798           * Synopsis     void tw_widget_init(void);
1799           * Description  init for tw widget system 初始化?面系y
1800           * Parameters   none
1801           * Return       none
1802           * NOTE         enter first page (first page of ID default is 1)
1803           */
1804          void tw_widget_init(void)
C51 COMPILER V7.50   TW_WIDGET_SYS                                                         06/16/2017 08:24:38 PAGE 31  

1805          {
1806   1        TW_EVENT page_event;
1807   1        page_event.type = TW_EVENT_TYPE_ENTER_SYSTEM;
1808   1        page_event.page.id = 1;   // allways first page
1809   1        put_event(&page_event);
1810   1      }
1811          
1812          /* Status variable 
1813           *    SLIDE_LOCK        slide of direction
1814           *    LAYOUT_GROUP_NUM  remember layout of group for performance
1815           *    SECOND_IMG_ID     remember second imag/twbc of ID for performance
1816           *    FIRST_IMG_ADDR    remember 1st imag/twbc of base address for performance
1817           *    SECOND_IMG_ADDR   remember 2nd imag/twbc of base address for performance
1818           */
1819          static unsigned char data SLIDE_LOCK= SLIDE_NONE;
1820          static unsigned char  LAYOUT_GROUP_NUM= 0xFF;
1821          static unsigned short   SECOND_IMG_ID = 0x0000;
1822          static unsigned long  FIRST_IMG_ADDR  = 0x0000;
1823          static unsigned long  SECOND_IMG_ADDR = 0x0000;
1824          
1825          /*
1826           * Synopsis     unsigned char tw_img_slide(struct tw_layout* playout, 
1827           *                                         unsigned char dir,
1828           *                                         unsigned long offset,
1829           *                                         unsigned char i,
1830           *                                         unsigned char j);
1831           * Description  image of slide effect             img?面滑有Ч
1832           * Parameters   *playout  - point of tw_layout of struct    ?面布局Y?指
1833           *        dir       - slide of direction        滑臃较
1834           *              offset    - slide of offset         滑恿
1835           *              i       - number of row in layout     ?面行
1836           *              j       - number of column in layout    ?面列
1837           * Return       0xFE: slide successful              滑映晒
1838           *              0xFF: slide error               滑邮
1839           *              other value: current stay of number in layout 目前@示布局物件??
1840           */
1841          unsigned char tw_img_slide(struct tw_layout* playout, unsigned char dir, unsigned long offset, unsigned ch
             -ar i, unsigned char j)
1842          {
1843   1        unsigned char c_w= 0, c_h= 0;
1844   1        unsigned long addr= 0, shift= 0;
1845   1        struct res_img_t      img_s;
1846   1        struct tw_img     *pimg;
1847   1        struct tw_layout_item *playout_item;
1848   1      
1849   1        unsigned long temp= 0;
1850   1      
1851   1        //offset = (offset/TD_LINE_ALING)*TD_LINE_ALING;  // ALIGN 4
1852   1        if(offset<=0)
1853   1          return SLIDE_HV_ERROR;
1854   1      
1855   1        if(i!=LAYOUT_GROUP_NUM) {
1856   2          LAYOUT_GROUP_NUM = i;
1857   2          FIRST_IMG_ADDR = 0;
1858   2          /* disable sprite & td */
1859   2          sosd_td_disable();
1860   2          sosd_sp_disable();
1861   2        }
1862   1          
1863   1        /* get current image base address */
1864   1        _get_img_idx_addr(&addr);
1865   1      
C51 COMPILER V7.50   TW_WIDGET_SYS                                                         06/16/2017 08:24:38 PAGE 32  

1866   1        /* get first image base address */
1867   1        pimg = playout->group[i].item[0].tw_object;
1868   1        get_res_img_by_addr(pimg->imgID, &img_s, &FIRST_IMG_ADDR);
1869   1      
1870   1        /* calc current of cnt at group */
1871   1        shift = addr-img_s.index_addr;
1872   1        c_w = ((shift%(img_s.line_jump))/img_s.width);
1873   1        c_h = ((shift/(img_s.line_jump))/(img_s.height)); 
1874   1        c_w = c_w+c_h*playout->group[i].width;
1875   1          
1876   1          /* get current of ID & Object */
1877   1        pimg = playout->group[i].item[c_w].tw_object;
1878   1        if(pimg->imgID!=SECOND_IMG_ID) {
1879   2          SECOND_IMG_ID = pimg->imgID;
1880   2          SECOND_IMG_ADDR = 0;
1881   2        }
1882   1        get_res_img_by_addr(pimg->imgID, &img_s, &SECOND_IMG_ADDR);
1883   1      
1884   1          shift = addr-img_s.index_addr;
1885   1        
1886   1        switch(dir) {
1887   2          case DIR_LEFT:  // left dir of slide
1888   2            /* check next image if current address == n image start address */
1889   2            if((addr==img_s.index_addr)) {
1890   3              SLIDE_LOCK = SLIDE_NONE;  // slide init
1891   3              if(playout->group[i].item[j].right==NULL) {
1892   4                if((playout->group[i].item[j].jump==NULL)) {
1893   5                  dbg(0, ("Can't left slide!\n"));
1894   5                  return SLIDE_HV_ERROR;
1895   5                } else {
1896   5                  playout_item = playout->group[i].item[j].jump;
1897   5                  if(playout_item->right==NULL) {
1898   6                    dbg(0, ("Can't left slide!\n"));
1899   6                    return SLIDE_HV_ERROR;
1900   6                  } else {
1901   6                    /* Load sLUT */
1902   6                    playout_item = 
1903   6                      (struct tw_layout_item*)playout->group[i].item[j].jump;
1904   6                    pimg = playout_item->tw_object;
1905   6                    tw_img_draw(pimg);
1906   6                    
1907   6                    playout_item = 
1908   6                      (struct tw_layout_item*)playout_item->right;
1909   6                    pimg = playout_item->tw_object;             
1910   6                    get_res_img(pimg->imgID, &img_s);
1911   6                    _sosd_sLUT_addr(img_s.lut_addr);
1912   6                    _sosd_load_slut();
1913   6                    _sosd_swtc_offset(img_s.width);
1914   6                    _sosd_swtc_h_mode();
1915   6                    _sosd_swtc_enable();
1916   6                    sosd_update();
1917   6                    _sosd_swtc_offset(img_s.width);
1918   6                  }
1919   5                }   
1920   4              } else {
1921   4                /* Load sLUT */
1922   4                playout_item = 
1923   4                  (struct tw_layout_item*)playout->group[i].item[j].right;
1924   4                pimg = playout_item->tw_object;
1925   4                get_res_img(pimg->imgID, &img_s);
1926   4                _sosd_sLUT_addr(img_s.lut_addr);
1927   4                _sosd_load_slut();          
C51 COMPILER V7.50   TW_WIDGET_SYS                                                         06/16/2017 08:24:38 PAGE 33  

1928   4                _sosd_swtc_h_mode();
1929   4                _sosd_swtc_enable();
1930   4                sosd_update();
1931   4                _sosd_swtc_offset(img_s.width);
1932   4              }
1933   3            } 
1934   2            /* next page */
1935   2            if((((shift)%(img_s.line_jump))+offset)
1936   2              >=img_s.width) {
1937   3              _sosd_swtc_disable();
1938   3              playout_item = 
1939   3                (struct tw_layout_item*)playout->group[i].item[c_w].right;
1940   3              pimg = playout_item->tw_object;
1941   3              tw_img_draw(pimg);
1942   3              sosd_enable(LOAD_LUT);
1943   3              CUR_BK_ID= pimg->imgID;
1944   3              SLIDE_LOCK = SLIDE_NONE;  // slide init
1945   3              return c_w;
1946   3            }
1947   2            /* left slide */
1948   2            else {
1949   3              _sosd_img_addr(addr+offset);
1950   3              addr = offset;
1951   3              _get_swtc_offset((unsigned short*)&offset);
1952   3              offset >>= 16;        
1953   3              sosd_update();
1954   3              _sosd_swtc_offset(offset-addr);
1955   3              SLIDE_LOCK = SLIDE_H_DIR;
1956   3              return SLIDE_MOTION;
1957   3            }
1958   2            break;
1959   2          case DIR_RIGHT: // right dir of slide
1960   2            /* check next image if current address == n image start address */
1961   2            if((addr==img_s.index_addr)) {
1962   3              SLIDE_LOCK = SLIDE_NONE;  // slide init
1963   3              if(playout->group[i].item[j].left==NULL) {
1964   4                if((playout->group[i].item[j].jump==NULL)) {
1965   5                  dbg(0, ("Can't left slide!\n"));
1966   5                  return SLIDE_HV_ERROR;
1967   5                } else {
1968   5                  playout_item = 
1969   5                    (struct tw_layout_item*)playout->group[i].item[j].jump;
1970   5                  if(playout_item->left==NULL) {
1971   6                    dbg(0, ("Can't left slide!\n"));
1972   6                    return SLIDE_HV_ERROR;
1973   6                  } else {
1974   6                    /* Load sLUT */
1975   6                    playout_item = 
1976   6                      (struct tw_layout_item*)playout->group[i].item[j].jump;
1977   6                    pimg = playout_item->tw_object;
1978   6                    get_res_img(pimg->imgID, &img_s);
1979   6                    _sosd_sLUT_addr(img_s.lut_addr);
1980   6                    tw_img_draw(pimg);
1981   6                    playout_item = 
1982   6                      (struct tw_layout_item*)playout_item->left;
1983   6                    pimg = playout_item->tw_object;
1984   6                    _sosd_pLUT_addr(img_s.lut_addr);
1985   6                    _sosd_load_plut();              
1986   6                    _sosd_swtc_h_mode();
1987   6                    _sosd_swtc_offset(0);
1988   6                    
1989   6                    _sosd_swtc_enable();
C51 COMPILER V7.50   TW_WIDGET_SYS                                                         06/16/2017 08:24:38 PAGE 34  

1990   6                    sosd_pLUTsLUT_load();
1991   6                    
1992   6                    pimg = playout->group[i].item[c_w].tw_object;
1993   6                    get_res_img(pimg->imgID, &img_s);
1994   6                  }
1995   5                }   
1996   4              } else {
1997   4                /* Load sLUT */
1998   4                _sosd_sLUT_addr(img_s.lut_addr);
1999   4                playout_item = 
2000   4                  (struct tw_layout_item*)playout->group[i].item[j].left;
2001   4                pimg = playout_item->tw_object;
2002   4                get_res_img(pimg->imgID, &img_s);
2003   4                _sosd_pLUT_addr(img_s.lut_addr);          
2004   4                _sosd_swtc_h_mode();
2005   4                _sosd_swtc_offset(0);
2006   4                
2007   4                _sosd_swtc_enable();
2008   4                sosd_pLUTsLUT_load();
2009   4      
2010   4                pimg = playout->group[i].item[c_w].tw_object;
2011   4                get_res_img(pimg->imgID, &img_s);
2012   4              }
2013   3            } 
2014   2            /* next page */
2015   2            if((((shift)%(img_s.line_jump))<=offset)
2016   2              &&(addr!=img_s.index_addr)) {
2017   3              _sosd_swtc_disable();
2018   3              pimg = playout->group[i].item[c_w].tw_object;
2019   3              tw_img_draw(pimg);
2020   3              sosd_update();
2021   3              CUR_BK_ID= pimg->imgID;
2022   3              SLIDE_LOCK = SLIDE_NONE;  // slide init
2023   3              return c_w;
2024   3            }
2025   2            /* right slide */
2026   2            else {
2027   3              _sosd_img_addr(addr-offset);
2028   3              addr = offset;
2029   3              _get_swtc_offset((unsigned short*)&offset);
2030   3              offset >>= 16;
2031   3              sosd_update();
2032   3              _sosd_swtc_offset(addr+offset);
2033   3              SLIDE_LOCK = SLIDE_H_DIR;
2034   3              return SLIDE_MOTION;
2035   3            }
2036   2            break;
2037   2          case DIR_UP:  // up dir of slide
2038   2            if(c_w!=j) {
2039   3              CUR_BK_ID= pimg->imgID;
2040   3              j= c_w;
2041   3            }
2042   2            /* check next image if current address == n image start address */
2043   2            if(addr==img_s.index_addr) {
2044   3              if(playout->group[i].item[j].down==NULL) {
2045   4                dbg(0, ("Can't UP slide!\n"));
2046   4                SLIDE_LOCK = SLIDE_NONE;
2047   4                return SLIDE_HV_ERROR;    
2048   4              } else {
2049   4                /* Load sLUT */
2050   4                playout_item = 
2051   4                  (struct tw_layout_item*)playout->group[i].item[j].down;
C51 COMPILER V7.50   TW_WIDGET_SYS                                                         06/16/2017 08:24:38 PAGE 35  

2052   4                pimg = playout_item->tw_object;
2053   4                get_res_img(pimg->imgID, &img_s);
2054   4                _sosd_sLUT_addr(img_s.lut_addr);
2055   4                _sosd_load_slut();
2056   4                _sosd_swtc_v_mode();
2057   4                _sosd_swtc_enable();
2058   4                sosd_update();
2059   4                _sosd_swtc_offset(img_s.height+2);
2060   4              }
2061   3            }
2062   2            /* next page */
2063   2            if((((shift)/(img_s.line_jump))+offset)
2064   2              >=((img_s.height))) {
2065   3              _sosd_swtc_disable();
2066   3              playout_item = 
2067   3                (struct tw_layout_item*)playout->group[i].item[c_w].down;
2068   3              pimg = playout_item->tw_object;
2069   3              tw_img_draw(pimg);
2070   3              sosd_enable(LOAD_LUT);
2071   3              CUR_BK_ID= pimg->imgID;
2072   3              SLIDE_LOCK = SLIDE_NONE;  // slide init
2073   3              return c_w;
2074   3            }
2075   2            /* up slide */
2076   2            else {
2077   3              _sosd_img_addr(addr+(offset*(img_s.line_jump)));
2078   3              addr = offset;
2079   3              _get_swtc_offset((unsigned short*)&offset);       
2080   3              offset >>= 16;
2081   3              sosd_update();
2082   3              _sosd_swtc_offset(offset-addr);
2083   3              SLIDE_LOCK = SLIDE_V_DIR;
2084   3              return SLIDE_MOTION;
2085   3            }
2086   2            break;
2087   2          case DIR_DOWN:  // down dir of slide
2088   2            if(c_w!=j) {
2089   3              CUR_BK_ID= pimg->imgID;
2090   3              j= c_w;
2091   3            }
2092   2            /* check next image if current address == n image start address */
2093   2            if(addr==img_s.index_addr) {
2094   3              if(playout->group[i].item[j].up==NULL) {
2095   4                dbg(0, ("Can't down slide!\n"));
2096   4                SLIDE_LOCK = SLIDE_NONE;  // slide init
2097   4                return SLIDE_HV_ERROR;
2098   4              } else {
2099   4                /* Load sLUT */
2100   4                _sosd_sLUT_addr(img_s.lut_addr);
2101   4                playout_item = 
2102   4                  (struct tw_layout_item*)playout->group[i].item[j].up;
2103   4                pimg = playout_item->tw_object;
2104   4                get_res_img(pimg->imgID, &img_s);
2105   4                _sosd_pLUT_addr(img_s.lut_addr);
2106   4                _sosd_swtc_v_mode();
2107   4                _sosd_swtc_offset(2);
2108   4                
2109   4                _sosd_swtc_enable();
2110   4                sosd_pLUTsLUT_load();
2111   4      
2112   4                pimg = playout->group[i].item[c_w].tw_object;
2113   4                get_res_img(pimg->imgID, &img_s);
C51 COMPILER V7.50   TW_WIDGET_SYS                                                         06/16/2017 08:24:38 PAGE 36  

2114   4              }
2115   3            }
2116   2            /* next page */
2117   2            if(((((shift)/(img_s.line_jump))
2118   2              %(img_s.height))<=offset)&&(addr!=img_s.index_addr)) {
2119   3              _sosd_swtc_disable();
2120   3      
2121   3              tw_img_draw(pimg);
2122   3              sosd_update();
2123   3              SLIDE_LOCK = SLIDE_NONE;  // slide init
2124   3              return c_w;
2125   3            } 
2126   2            /* down slide */
2127   2            else {
2128   3              _sosd_img_addr(addr-(offset*(img_s.line_jump)));
2129   3              addr = offset;
2130   3              _get_swtc_offset((unsigned short*)&offset);
2131   3              offset >>= 16;
2132   3              sosd_update();
2133   3              _sosd_swtc_offset(addr+offset);
2134   3              SLIDE_LOCK = SLIDE_V_DIR;
2135   3              return SLIDE_MOTION;
2136   3            }
2137   2            break;
2138   2        }
2139   1        return SLIDE_HV_ERROR;
2140   1      }
2141          
2142          /*
2143           * Synopsis     unsigned char tw_td_slide(struct tw_layout* playout,
2144           *                                        unsigned char dir,
2145           *                                        unsigned long offset,
2146           *                                        unsigned char i,
2147           *                                        unsigned char j);
2148           * Description  twbc of slide effect              TD移有Ч函
2149           * Parameters   *playout  - point of tw_layout of struct    ?面布局Y?指
2150           *        dir       - slide of direction        滑臃较
2151           *              offset    - slide of offset         滑恿
2152           *              i       - number of row in layout     ?面行
2153           *              j       - number of column in layout    ?面列
2154           * Return       0xFE: slide successful              滑映晒
2155           *              0xFF: slide error               滑邮
2156           *              other value: current stay of number in layout 目前@示布局物件??
2157           */
2158          #define TD_LINE_DUMMY 8
2159          #define TD_LINE_ALING 4
2160          unsigned char tw_td_slide(struct tw_layout* playout, unsigned char dir, unsigned long offset, unsigned cha
             -r i, unsigned char j)
2161          {
2162   1        unsigned char c_w= 0, c_h= 0;
2163   1        unsigned long addr= 0, shift= 0;
2164   1        struct res_td_t     img_s;
2165   1        struct tw_td      *pimg;
2166   1        struct tw_layout_item *playout_item;
2167   1      
2168   1        offset = (offset/TD_LINE_ALING)*TD_LINE_ALING;  // ALIGN 4
2169   1        if(offset<=0)
2170   1          return SLIDE_HV_ERROR;
2171   1      
2172   1        if(i!=LAYOUT_GROUP_NUM) {
2173   2          LAYOUT_GROUP_NUM = i;
2174   2          FIRST_IMG_ADDR = 0;
C51 COMPILER V7.50   TW_WIDGET_SYS                                                         06/16/2017 08:24:38 PAGE 37  

2175   2        }
2176   1      
2177   1        /* get current image base address */
2178   1        _get_tdc_addr(&addr);
2179   1      
2180   1        /* get first image base address */
2181   1        pimg = playout->group[i].item[0].tw_object;
2182   1        get_res_td_by_addr(pimg->tdID, &img_s, &FIRST_IMG_ADDR);
2183   1      
2184   1        /* calc current of cnt at group */
2185   1        shift = addr-img_s.color_addr;
2186   1        c_w = ((shift%(img_s.line_jump+TD_LINE_DUMMY))/img_s.width);
2187   1        c_h = ((shift/(img_s.line_jump+TD_LINE_DUMMY))/(img_s.height/TD_LINE_ALING)); 
2188   1        c_w = c_w+c_h*playout->group[i].width;
2189   1      
2190   1        /* get current of ID & Object */
2191   1        pimg = playout->group[i].item[c_w].tw_object;
2192   1        if(pimg->tdID!=SECOND_IMG_ID) {
2193   2          SECOND_IMG_ID = pimg->tdID;
2194   2          SECOND_IMG_ADDR = 0;
2195   2        }
2196   1        get_res_td_by_addr(pimg->tdID, &img_s, &SECOND_IMG_ADDR);
2197   1      
2198   1        switch(dir) {
2199   2          case DIR_LEFT:  // left dir of slide
2200   2            /* check next image if current address == n image start address */
2201   2            if((addr==img_s.color_addr)) {
2202   3              SLIDE_LOCK = SLIDE_NONE;  // slide init
2203   3              if(playout->group[i].item[j].right==NULL) {
2204   4                if((playout->group[i].item[j].jump==NULL)) {
2205   5                  dbg(0, ("Can't left slide!\n"));
2206   5                  return SLIDE_HV_ERROR;
2207   5                } else {
2208   5                  playout_item = playout->group[i].item[j].jump;
2209   5                  if(playout_item->right==NULL) {
2210   6                    dbg(0, ("Can't left slide!\n"));
2211   6                    return SLIDE_HV_ERROR;
2212   6                  }
2213   5                }   
2214   4              }
2215   3            }
2216   2            /* jump 2 next group if shift > linejump */
2217   2            if((shift%(img_s.line_jump+TD_LINE_DUMMY))
2218   2              >=(img_s.line_jump-img_s.width)) {
2219   3              if((playout->group[i].item[j].jump!=NULL)) {
2220   4                playout_item = 
2221   4                  (struct tw_layout_item*)playout->group[i].item[j].jump;
2222   4                pimg = playout_item->tw_object;
2223   4                tw_td_draw(pimg);
2224   4                get_res_td(pimg->tdID, &img_s);
2225   4                _sosd_tdc_addr(img_s.color_addr+offset);
2226   4                _sosd_img_addr(img_s.index_addr+(offset/TD_LINE_ALING));
2227   4                sosd_update();
2228   4                dbg(3, ("tw_td_draw imgID= %u!\n", pimg->tdID));
2229   4                return SLIDE_MOTION;
2230   4              } else {
2231   4                dbg(0, ("Can't jump!\n"));
2232   4                return SLIDE_HV_ERROR;
2233   4              }
2234   3            } 
2235   2            /* next page */
2236   2            else if((((addr-img_s.color_addr)%(img_s.line_jump+TD_LINE_DUMMY))+offset)
C51 COMPILER V7.50   TW_WIDGET_SYS                                                         06/16/2017 08:24:38 PAGE 38  

2237   2              >=img_s.width) {
2238   3              playout_item = 
2239   3                (struct tw_layout_item*)playout->group[i].item[c_w].right;
2240   3              pimg = playout_item->tw_object;
2241   3              tw_td_draw(pimg);
2242   3              sosd_update();
2243   3              CUR_BK_ID= pimg->tdID;
2244   3              SLIDE_LOCK = SLIDE_NONE;  // slide init
2245   3              return c_w;
2246   3            }
2247   2            /* left slide */
2248   2            else {
2249   3              _sosd_tdc_addr(addr+offset);
2250   3              _get_img_idx_addr(&addr);
2251   3              _sosd_img_addr(addr+(offset/TD_LINE_ALING));
2252   3              sosd_update();
2253   3              SLIDE_LOCK = SLIDE_H_DIR;
2254   3              return SLIDE_MOTION;
2255   3            }
2256   2            break;
2257   2          case DIR_RIGHT: // right dir of slide
2258   2            /* check next image if current address == n image start address */
2259   2            if((addr==img_s.color_addr)) {
2260   3              SLIDE_LOCK = SLIDE_NONE;  // slide init
2261   3              if(playout->group[i].item[j].left==NULL) {
2262   4                if((playout->group[i].item[j].jump==NULL)) {
2263   5                  dbg(0, ("Can't left slide!\n"));
2264   5                  return SLIDE_HV_ERROR;
2265   5                } else {
2266   5                  playout_item = 
2267   5                    (struct tw_layout_item*)playout->group[i].item[j].jump;
2268   5                  if(playout_item->left==NULL) {
2269   6                    dbg(0, ("Can't left slide!\n"));
2270   6                    return SLIDE_HV_ERROR;
2271   6                  }
2272   5                }   
2273   4              }
2274   3            }
2275   2            /* jump 2 next group if shift <= 0 */
2276   2            if((shift%(img_s.line_jump+TD_LINE_DUMMY))==0) {
2277   3              if((playout->group[i].item[j].jump!=NULL)) {
2278   4                playout_item = 
2279   4                  (struct tw_layout_item*)playout->group[i].item[j].jump;
2280   4                pimg = playout_item->tw_object;
2281   4                tw_td_draw(pimg);
2282   4                get_res_td(pimg->tdID, &img_s);
2283   4                _sosd_tdc_addr(img_s.color_addr-offset);
2284   4                _sosd_img_addr(img_s.index_addr-(offset/TD_LINE_ALING));
2285   4                sosd_update();
2286   4                dbg(3, ("tw_td_draw imgID= %u!\n", pimg->tdID));
2287   4                return SLIDE_MOTION;
2288   4              } else {
2289   4                dbg(0, ("Can't jump!\n"));
2290   4                return SLIDE_HV_ERROR;
2291   4              }
2292   3            } 
2293   2            /* next page */
2294   2            else if((((addr-img_s.color_addr)%(img_s.line_jump+TD_LINE_DUMMY))<=offset)
2295   2              &&(addr!=img_s.color_addr)) {
2296   3              pimg = playout->group[i].item[c_w].tw_object;
2297   3              tw_td_draw(pimg);
2298   3              sosd_update();
C51 COMPILER V7.50   TW_WIDGET_SYS                                                         06/16/2017 08:24:38 PAGE 39  

2299   3              CUR_BK_ID= pimg->tdID;
2300   3              SLIDE_LOCK = SLIDE_NONE;  // slide init
2301   3              return c_w;
2302   3            }
2303   2            /* right slide */
2304   2            else {        
2305   3              _sosd_tdc_addr(addr-offset);
2306   3              _get_img_idx_addr(&addr);
2307   3              _sosd_img_addr(addr-(offset/TD_LINE_ALING));
2308   3                sosd_update();
2309   3              CUR_BK_ID= pimg->tdID;
2310   3              SLIDE_LOCK = SLIDE_H_DIR;
2311   3              return SLIDE_MOTION;
2312   3            }
2313   2            break;
2314   2          case DIR_UP:  // up dir of slide
2315   2            if(c_w!=j) {
2316   3              CUR_BK_ID= pimg->tdID;
2317   3              j= c_w;
2318   3            }
2319   2            /* check next image if current address == n image start address */
2320   2            if(addr==img_s.color_addr) {
2321   3              if(playout->group[i].item[j].down==NULL) {
2322   4                dbg(0, ("Can't UP slide!\n"));
2323   4                SLIDE_LOCK = SLIDE_NONE;
2324   4                return SLIDE_HV_ERROR;    
2325   4              }
2326   3            }
2327   2            offset = offset/TD_LINE_ALING;
2328   2            /* next page */
2329   2            if((((addr-img_s.color_addr)/(img_s.line_jump+TD_LINE_DUMMY))+offset)
2330   2              >=((img_s.height/TD_LINE_ALING))) {
2331   3              playout_item = 
2332   3                (struct tw_layout_item*)playout->group[i].item[c_w].down;
2333   3              pimg = playout_item->tw_object;
2334   3              tw_td_draw(pimg);
2335   3              sosd_update();
2336   3              CUR_BK_ID= pimg->tdID;
2337   3              SLIDE_LOCK = SLIDE_NONE;  // slide init
2338   3              return c_w;
2339   3            }
2340   2            /* up slide */
2341   2            else {
2342   3              _sosd_tdc_addr(addr+(offset*(img_s.line_jump+TD_LINE_DUMMY)));
2343   3              _get_img_idx_addr(&addr);
2344   3              _sosd_img_addr(addr+(offset*img_s.line_jump));
2345   3              sosd_update();
2346   3              SLIDE_LOCK = SLIDE_V_DIR;
2347   3              return SLIDE_MOTION;
2348   3            }
2349   2            break;
2350   2          case DIR_DOWN:  // down dir of slide
2351   2            if(c_w!=j) {
2352   3              CUR_BK_ID= pimg->tdID;
2353   3              j= c_w;
2354   3            }
2355   2            /* check next image if current address == n image start address */
2356   2            if(addr==img_s.color_addr) {
2357   3              if(playout->group[i].item[j].up==NULL) {
2358   4                dbg(0, ("Can't down slide!\n"));
2359   4                SLIDE_LOCK = SLIDE_NONE;  // slide init
2360   4                return SLIDE_HV_ERROR;
C51 COMPILER V7.50   TW_WIDGET_SYS                                                         06/16/2017 08:24:38 PAGE 40  

2361   4              }
2362   3            }
2363   2            offset = offset/TD_LINE_ALING;
2364   2            /* next page */
2365   2            if(((((addr-img_s.color_addr)/(img_s.line_jump+TD_LINE_DUMMY))
2366   2              %(img_s.height/TD_LINE_ALING))<=offset)&&(addr!=img_s.color_addr)) {
2367   3              _sosd_tdc_addr(img_s.color_addr);
2368   3              _sosd_img_addr(img_s.index_addr);
2369   3                sosd_update();
2370   3              SLIDE_LOCK = SLIDE_NONE;  // slide init
2371   3              return c_w;
2372   3            } 
2373   2            /* down slide */
2374   2            else {
2375   3              _sosd_tdc_addr(addr-(offset*(img_s.line_jump+TD_LINE_DUMMY)));
2376   3              _get_img_idx_addr(&addr);
2377   3              _sosd_img_addr(addr-(offset*img_s.line_jump));
2378   3                sosd_update();
2379   3              SLIDE_LOCK = SLIDE_V_DIR;
2380   3              return SLIDE_MOTION;
2381   3            }
2382   2            break;
2383   2        }
2384   1        return SLIDE_HV_ERROR;
2385   1      }
2386          
2387          /*
2388           * Synopsis     void tw_slide_init(void);
2389           * Description  slide init  滑有Ч初始化
2390           * Parameters   none
2391           * Return       none
2392           */
2393          void tw_slide_init(void)
2394          {
2395   1        LAYOUT_GROUP_NUM= 0xFF;
2396   1        SECOND_IMG_ID = 0x0000;
2397   1        FIRST_IMG_ADDR  = 0x0000;
2398   1        SECOND_IMG_ADDR = 0x0000;
2399   1        SLIDE_LOCK = SLIDE_NONE;
2400   1        sosd_sw_tc_disable();
2401   1      }
2402          
2403          /*
2404           * Synopsis     unsigned char tw_search_ele(struct tw_layout* playout,
2405           *                                        unsigned char *g,
2406           *                                        unsigned char *w);
2407           * Description  search current of ele in layout         搜つ壳帮@示?面??     
2408           * Parameters   *playout  - point of tw_layout of struct    ?面布局Y?指      
2409           *              *g        - point of row            ?面行
2410           *              *w        - point of column         ?面列 
2411           * Return       0xFE: slide successful              滑映晒
2412           *              0xFF: slide error               滑邮
2413           *              other value: current stay of number in layout 目前@示布局物件??
2414           */
2415          unsigned char tw_search_ele(struct tw_layout* playout, unsigned char *g, unsigned char *w)
2416          {
2417   1        unsigned char i= 0, j= 0, c_w= 0;
2418   1        struct tw_img *pimg;
2419   1      
2420   1        for(i=0; i<playout->cnt; i++) {
2421   2          for(j=0; j<(playout->group[i].width*playout->group[i].height); j++) {
2422   3            pimg = (struct tw_img*)playout->group[i].item[j].tw_object;
C51 COMPILER V7.50   TW_WIDGET_SYS                                                         06/16/2017 08:24:38 PAGE 41  

2423   3            if(pimg->imgID==CUR_BK_ID) {
2424   4              c_w = 1;
2425   4              break;
2426   4            }
2427   3          }
2428   2          if(c_w)
2429   2            break;
2430   2        }
2431   1      
2432   1        if(i>=playout->cnt) {
2433   2          dbg(0, ("i= %bu, j= %bu!\n", i, j));
2434   2          ERROR(("Group Out Range!\n"));
2435   2          return SLIDE_HV_ERROR;
2436   2        }
2437   1        if(j>=(playout->group[i].width*playout->group[i].height)) {
2438   2          ERROR(("Group[%bu]: Item Out Range!\n", i));
2439   2          return SLIDE_HV_ERROR;
2440   2        }
2441   1      
2442   1        *g = i;
2443   1        *w = j;
2444   1      
2445   1        return 0;
2446   1      }
2447          
2448          /*
2449           * Synopsis     unsigned char tw_page_slide(struct tw_layout* playout,
2450           *                                        unsigned char dir,
2451           *                                        unsigned long offset);
2452           * Description  background of slide effect            背景滑有Ч
2453           * Parameters   *playout  - point of tw_layout of struct    ?面布局Y?指
2454           *        dir       - slide of direction        滑臃较
2455           *              offset    - slide of offset         移恿
2456           * Return       0xFE: slide successful              移油瓿  
2457           *              0xFF: slide error               移邮
2458           *              other value: current stay of number in layout 目前@示布局物件??
2459           */
2460          unsigned char tw_page_slide(struct tw_layout* playout, unsigned char dir, unsigned short offset)
2461          {
2462   1        unsigned char i= 0, j= 0, c_w= 0;
2463   1      
2464   1        if(offset<=0)
2465   1          return SLIDE_HV_ERROR;
2466   1      
2467   1        switch(dir) {
2468   2          case DIR_LEFT:
2469   2          case DIR_RIGHT:
2470   2            if(SLIDE_LOCK==SLIDE_V_DIR) {
2471   3              INFO(("can't H slide, current is V slide!\n"));
2472   3              return SLIDE_HV_ERROR;
2473   3            }
2474   2            break;
2475   2          case DIR_UP:
2476   2          case DIR_DOWN:
2477   2            if(SLIDE_LOCK==SLIDE_H_DIR) {
2478   3              INFO(("can't V slide, current is H slide!\n"));
2479   3              return SLIDE_HV_ERROR;
2480   3            }
2481   2            break;
2482   2        }
2483   1      
2484   1        c_w = tw_search_ele(playout, &i, &j);
C51 COMPILER V7.50   TW_WIDGET_SYS                                                         06/16/2017 08:24:38 PAGE 42  

2485   1        if(c_w!=0)
2486   1          return c_w;
2487   1      
2488   1        switch(playout->type) {
2489   2          case IMG_SLIDE:
2490   2            c_w = tw_img_slide(playout, dir, offset, i, j);
2491   2            break;
2492   2          case TD_SLIDE:
2493   2            c_w = tw_td_slide(playout, dir, offset, i, j);
2494   2            break;
2495   2        }
2496   1      
2497   1        if((c_w!=SLIDE_MOTION)&&(c_w!=SLIDE_HV_ERROR)) {
2498   2          c_w = tw_search_ele(playout, &i, &j);
2499   2          if(c_w!=0)
2500   2            return c_w;
2501   2          else {
2502   3            c_w = (playout->group[0].width*playout->cnt)-(playout->cnt-1);
2503   3            return (j%playout->group[0].width)+(j/playout->group[0].width*c_w)+(i*(playout->group[0].width-1))+1;   
             -  
2504   3          } 
2505   2        } else
2506   1          return c_w;
2507   1      }
2508          
2509          
2510          struct tw_scl_txt _init_scrol(struct tw_txt* ptxt, unsigned short *ucs, unsigned char direct, unsigned cha
             -r tail_blank, unsigned char is2bp) {
2511   1        struct tw_scl_txt ret;
2512   1        unsigned char is_half_alphabet = (_tw_half_alphabet_num() > 0);   
2513   1        unsigned short font_size = CUR_MENU_P->font_w*CUR_MENU_P->font_h/16;  
2514   1        unsigned char i;
2515   1        unsigned char size_id = _tw_get_font_size_id();
2516   1        unsigned char w_count;
2517   1        unsigned char bp = (is2bp) ? 2 : 1;
2518   1          unsigned short real_oaddr;
2519   1                 
2520   1        tw_menu_reset_index_n(ptxt->index);
2521   1        for(i=0; ucs[i]!=0 && i < 0xff; i++) {
2522   2              real_oaddr = (is2bp) ? (CUR_2BP_IDX*font_size + (menu_string_start_index-CUR_2BP_IDX)*font_size*2)
             - : font_size*menu_string_start_index;  
2523   2            if(is_half_alphabet && ucs[i] < 256) {
2524   3            w_count = osd_put_twf_char_to_oram(CUR_TOF_RES.base_addr, real_oaddr, ucs[i],
2525   3                             font_size*TOF_FONT_SPLIT_H[size_id]*2*bp, is_half_alphabet);   
2526   3            menu_string_start_index += w_count*TOF_FONT_SPLIT_H[size_id];
2527   3          }
2528   2          else {                                           
2529   3            osd_put_twf_char_to_oram(CUR_TOF_RES.base_addr, real_oaddr, ucs[i], 
2530   3                             font_size*TOF_FONT_SPLIT_W[size_id]*TOF_FONT_SPLIT_H[size_id]*2*bp, is_half_alphabet); 
2531   3            menu_string_start_index += TOF_FONT_SPLIT_W[size_id]*TOF_FONT_SPLIT_H[size_id];
2532   3          }
2533   2        }
2534   1          real_oaddr = (is2bp) ? (CUR_2BP_IDX*font_size + (menu_string_start_index-CUR_2BP_IDX)*font_size*2) : f
             -ont_size*menu_string_start_index;      
2535   1        osd_put_twf_char_to_oram(CUR_TOF_RES.base_addr, real_oaddr, 0x20, font_size*2*bp, is_half_alphabet); 
2536   1        
2537   1        ret.total_len = (menu_string_start_index - ptxt->index) / TOF_FONT_SPLIT_H[size_id];  
2538   1        ret.direct = direct;  
2539   1        ret.tail_blank = tail_blank; 
2540   1        ret.cur_index = ptxt->index; 
2541   1        ret.size_id = size_id; 
2542   1        ret.ptxt = ptxt;  
C51 COMPILER V7.50   TW_WIDGET_SYS                                                         06/16/2017 08:24:38 PAGE 43  

2543   1       
2544   1        tw_scrolling(&ret);
2545   1        
2546   1        return ret; 
2547   1      
2548   1      }
2549          
2550           /*
2551           * Synopsis     struct tw_scl_txt tw_init_scrol(struct tw_txt* ptxt,
2552           *                                              unsigned short *ucs,
2553           *                                              unsigned char direct,
2554           *                                            unsigned char tail_blank);
2555           * Get a marquee struct from a txt.
2556           * Parameters   *ptxt     - the txt going to make this marquee 
2557           *        *ucs    - the words going to draw on marquee
2558           *              direct    - the direction of this marquee (0:left  1:right)
2559           *              tail_blank  - the sum of blanks between the head and tail of each sequence
2560           * Return       tw_scl_txt  - the marquee struct used to drawing the input string           
2561           */
2562          struct tw_scl_txt tw_init_scrol(struct tw_txt* ptxt, unsigned short *ucs, unsigned char direct, unsigned c
             -har tail_blank)
2563          {
2564   1        return _init_scrol(ptxt, ucs, direct, tail_blank, 0);                   
2565   1      }
2566          
2567           /*
2568           * Synopsis     struct tw_scl_txt tw_init_scrol_2bp(struct tw_txt* ptxt,
2569           *                                                  unsigned short *ucs,
2570           *                                                  unsigned char direct,
2571           *                                                unsigned char tail_blank);
2572           * Get a 2bp marquee struct from a txt.
2573           * Parameters   *ptxt     - the txt going to make this marquee 
2574           *        *ucs    - the words going to draw on marquee
2575           *              direct    - the direction of this marquee (0:left  1:right)
2576           *              tail_blank  - the sum of blanks between the head and tail of each sequence
2577           * Return       tw_scl_txt  - the marquee struct used to drawing the input string           
2578           */
2579          struct tw_scl_txt tw_init_scrol_2bp(struct tw_txt* ptxt, unsigned short *ucs, unsigned char direct, unsign
             -ed char tail_blank)
2580          {
2581   1        return _init_scrol(ptxt, ucs, direct, tail_blank, 1);                   
2582   1      }
2583          
2584          void tw_scrolling(struct tw_scl_txt* scl_txt)
2585          {             
2586   1        unsigned char color = (scl_txt->ptxt->fg_color<<1L) + (scl_txt->ptxt->bg_color<<6L);
2587   1        unsigned short i, j, dW;  
2588   1        unsigned short dat;
2589   1        unsigned char split_h = TOF_FONT_SPLIT_H[scl_txt->size_id];
2590   1       
2591   1        unsigned short max_index = scl_txt->ptxt->index + scl_txt->total_len * split_h;     
2592   1        unsigned short color_h = (color<<8L);
2593   1        unsigned char blank_index_count = scl_txt->tail_blank*split_h;
2594   1        unsigned short disp_index_count = scl_txt->ptxt->width*split_h;  
2595   1      
2596   1        for(i=0; i<scl_txt->ptxt->width; i++) {
2597   2          for(j=0; j<split_h; j++) {      
2598   3            if(scl_txt->cur_index+i*split_h > max_index) {
2599   4              dW = (scl_txt->cur_index+i*split_h) - max_index;
2600   4              if(dW < blank_index_count) {
2601   5                dat = color_h + 0;  
2602   5                osd_set_location_addr(scl_txt->ptxt->x+i, scl_txt->ptxt->y+j, CUR_MENU_P->addr, CUR_MENU_P->width);   
C51 COMPILER V7.50   TW_WIDGET_SYS                                                         06/16/2017 08:24:38 PAGE 44  

             -     
2603   5                OSD_SET_RAM_DATA(dat);
2604   5              }
2605   4              else {
2606   5                dW = dW - blank_index_count;    
2607   5                dat = color_h + scl_txt->ptxt->index+dW+j;
2608   5                osd_set_location_addr(scl_txt->ptxt->x+i, scl_txt->ptxt->y+j, CUR_MENU_P->addr, CUR_MENU_P->width);   
             -         
2609   5                OSD_SET_RAM_DATA(dat);           
2610   5              }
2611   4            }
2612   3            else {   
2613   4              dat = color_h + scl_txt->cur_index + i*split_h+j; 
2614   4              osd_set_location_addr(scl_txt->ptxt->x+i, scl_txt->ptxt->y+j, CUR_MENU_P->addr, CUR_MENU_P->width);     
             -     
2615   4              OSD_SET_RAM_DATA(dat);
2616   4            }
2617   3          }
2618   2        }
2619   1      
2620   1        if(scl_txt->direct) {
2621   2          scl_txt->cur_index += split_h;  
2622   2          scl_txt->cur_index = scl_txt->ptxt->index + (scl_txt->cur_index - scl_txt->ptxt->index)%((scl_txt->total
             -_len + scl_txt->tail_blank)*split_h);
2623   2        }
2624   1        else {
2625   2          scl_txt->cur_index = (scl_txt->cur_index < split_h) ? 0 : scl_txt->cur_index - split_h;
2626   2          if(scl_txt->cur_index < scl_txt->ptxt->index) {
2627   3            scl_txt->cur_index = scl_txt->ptxt->index + (scl_txt->total_len + scl_txt->tail_blank - 1)*split_h; 
2628   3          } 
2629   2        } 
2630   1      }
2631          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  22320    ----
   CONSTANT SIZE    =    706    ----
   XDATA SIZE       =     45     746
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1      14
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
